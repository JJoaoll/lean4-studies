* Functional Programming in Lean
** Getting to know
*** Text resume
Lean4 does have a repl integrated with the LSP enviroment.

**** POO
This text talks so much about POO that hurt's me. I can't get so much POO anymore.

*** Evaluating
U should use the `#eval` to evaluate, such as this example show us:
#+begin_src lean4
  #eval 1 + 2
#+end_src

Also the function application works just like in Haskell.
(üîç) ~ So, i've just figured out that lean4 is a strict language, not a strict one. What a shame!
*** Types
When necessary, u can use type coercions with ":"
#+begin_src lean4
    #eval (1 + 2 : Nat)
    -- So look this:
    #eval  1 - 2        -->  0 : Nat
    #eval (1 - 2 : Int) --> -1 : Int
#+end_src

As u can check the values with  `#eval`
u also can check the types with `#check`
#+begin_src lean4
    #check (1 - 2 : Int)  --> 1 - 2 : Int (without performing the operation.)
#+end_src

*** Functions and Definitions
to definitions, use `def`, like:
#+begin_src lean4
    def hello := "Hello"
#+end_src

Note how great the `:=` fits for assignments instead of `=`.
If u wanna pick the type too, u can do it like this:
#+begin_src lean4
    def lean : String := "Lean"
#+end_src

When it comes to define a function, there are a variaty of ways to do that.
The simpliest one (they say it):
#+begin_src lean4
    def succ (n : Nat) : Nat := n + 1
    -- or:
    def pred (n : Nat) : Nat :=
        n - 1
#+end_src


Look this another one with more arguments:
#+begin_src lean4
    def maximum (n : Nat) (k : Nat) : Nat :=
      if n < k then
        k
      else n
#+end_src

Lean4 does use currying as default.
(my exercises are in somewhere but it's not my intent to share them :P)

**** Defining Types:
U use the same `def` keyword just like with the values (including functions)
#+begin_src lean4
    def Str  : Type := String
    def aStr : Str  := "Look at me, i'm a real String!"
#+end_src

some explanation about "aStr" definition:
"The reason this works is that types follow the same rules as the rest of Lean. Types are expressions,
and in an expression, a defined name can be replaced with its definition. Because Str has been defined
to mean String, the definition of aStr makes sense."

Something very very weird about Lean4 is that, because they want to overload number literals,
this code generates an error:
#+begin_src lean4
    def NaturalNumber : Type := Nat
    def thirtyEight : NaturalNumber := 38

    -- failed to synthesize instance
    -- OfNat NaturalNumber 38
#+end_src

But it works this way:
#+begin_src lean4
    def thirtyEight : NaturalNumber := (38 : Nat)
#+end_src

why?
"One way to work around this limitation is by providing the type Nat on the right-hand side of the definition, causing Nat's overloading rules to be used for 38:

The definition is still type-correct because NaturalNumber is the same type as Nat‚Äîby definition!"

But don't worry about it, we can see the light here:
"Another solution is to define an overloading for NaturalNumber that works equivalently to the one for Nat. This requires more advanced features of Lean, however."

Finally we have some "abbrev" like here:
#+begin_src lean4
    abbrev N : Type := Nat
    def thirtyNine : N := 39
    -- works well
#+end_src

**** Question:
whats a "foldable | unfoldable | folded | unfolded" definitions?

*** Structures
So they're basically product types..
#+begin_src lean4
    structure Point where
      x : Float
      y : Float
    deriving Repr

    def origin : Point := { x := 0.0, y := 0.0 }
#+end_src

Note that the deriving works as the `Show` in haskell.
When u call the "#eval", it call's the "repr". Look's like
we're gonna discover TypeClasses again..

About extracting things out of products we have:
#+begin_src lean4
    #eval origin.x
    #eval origin.y

    def addPoints (p1 : Point) (p2 : Point) : Point :=
        { x := p1.x + p2.x, y := p1.y + p2.y }

    structure Point3D where
        x : Float
        y : Float
        z : Float
    deriving Repr

    def origin3D : Point3D :=
        { x := 0.0, y := 0.0, z := 0.0 }
#+end_src

"To make programs more concise, Lean also allows the structure type annotation inside the curly braces."
#+begin_src lean4
    #check { x := 0.0, y := 0.0 : Point}
#+end_src

Another convenient syntax is:
#+begin_src lean4
    -- default
    def zeroX (p : Point) : Point :=
        { x := 0, y := p.y }
    -- with syntax
    def zeroX (p : Point) : Point :=
        { p with x := 0 }
#+end_src

With this syntax, some issues about refactoring code, e.g., adding new
new columns to a struct would not implie that u're refactoring every
single function that does things like above.

**** Structure constructor
So.. In Lean4, ure forced to use the "mk" thing that
u could avoid in Haskell after get some maturity..
#+begin_src lean4
    #check Point.mk 1.5 2.8
      --> { x := 1.5, y := 2.8 } : Point
#+end_src
It's just exacly how a constructor should be in a product type,
but forcing u to use de `(_.mk)` syntax, and what's ok.

- Fine, i was wrong. And the default.. Nice one, lean, nice one.
look at that:
#+begin_src lean4
    structure Point where
        point ::
        x : Float
        y : Float
    deriving Repr
#+end_src

Some notes about 'behind-the-scenes':
"In fact, just as the curly-braced structure construction syntax is converted to a call to the structure's constructor behind the scenes, the syntax p1.x in the prior definition of addPoints is converted into a call to the Point.x accessor. That is, #eval origin.x and #eval Point.x origin both yield"

LOOK AT THIS!!:
    Accessor dot notation is usable with more than just structure fields. It can also be used for functions that take any number of arguments. More generally, accessor notation has the form TARGET.f ARG1 ARG2 .... If TARGET has type T, the function named T.f is called. TARGET becomes its leftmost argument of type T, which is often but not always the first one, and ARG1 ARG2 ... are provided in order as the remaining arguments. For instance, String.append can be invoked from a string with accessor notation, even though String is not a structure with an append field.

#+begin_src lean4
    #eval "one string".append " and another"
#+end_src

(question?) - how the parenthesis works with `#eval` and `#check`?

*** Datatypes, Patterns and Recursion
It's module starts presenting what's a sum and a product of types in a
very simple and didactic way.

Also, the concept "inductive data types" were explained in this short-text:
"Datatypes that allow choices are called sum types and datatypes that can include instances of themselves are called recursive datatypes. Recursive sum types are called inductive datatypes, because mathematical induction may be used to prove statements about them. When programming, inductive datatypes are consumed through pattern matching and recursive functions."

But also look this definition:
#+begin_src lean4
    inductive Bool where
      | false : Bool
      | true  : Bool
#+end_src

About classical ones, we have:
#+begin_src lean4
    inductive Nat where
      | zero : Nat
      | succ (n : Nat) : Nat
#+end_src

**** Pattern Matching
Examples:
#+begin_src lean4
    def isZero (n : Nat) : Bool :=
        match n with
        | Nat.zero   => true
        | Nat.succ k => false

    def pred (n : Nat) : Nat :=
        match n with
        | Nat.zero   => Nat.zero
        | Nat.succ k => k
#+end_src

U can match with products just like sums (...)
#+begin_src lean4
    def depth (p : Point3D) : Float :=
        match p with
        | { x:= h, y := w, z := d } => d

    -- Better:
    def depth (p : Point3D) : Float :=
        match p with
        | Point3D.mk _ _ d => d
#+end_src

**** Recursive Functions
Examples:
#+begin_src lean4
    def even (n : Nat) : Bool :=
        match n with
        | Nat.zero   => true
        | Nat.succ k => not (even k)
#+end_src

"Lean ensures by default that every recursive function will eventually reach a base case"
#+begin_src lean4
    -- error:
    def evenLoops (n : Nat) : Bool :=
        match n with
        | Nat.zero   => true
        | Nat.succ k => not (evenLoops n)
#+end_src

Mensagem do erro:
"fail to show termination for
  evenLoops
with errors
structural recursion cannot be used

well-founded recursion cannot be used, 'evenLoops' does not take any (non-fixed) arguments
"

Another classical's:
#+begin_src lean4
    def plus (n : Nat) (k : Nat) : Nat :=
        match k with
        | Nat.zero    => n
        | Nat.succ k' => Nat.succ (plus n k')

    def times (n : Nat) (k : Nat) : Nat :=
        match k with
        | Nat.zero    => Nat.zero
        | Nat.succ k' => plus n (times n k')

    def monus* (n : Nat) (k : Nat) : Nat :=
        match k with
        | Nat.zero    => n
        | Nat.succ k' => pred (minus n k')
#+end_src

Algumas coisas sobre a termina√ß√£o da quot foram tratadas,
mas s√≥ ser√£o `terminadas` no √∫ltimo cap√≠tulo, portanto, nada
a mencionar por aqui.

*** Polymorphism
Look this amazing generalized point:
#+begin_src lean4
    structure PPoint (Œ± : Type) where
        x : Œ±
        y : Œ±
    deriving Repr
#+end_src

Usage example:
#+begin_src lean4
    def natOrigin : PPoint Nat :=
        { x := Nat.zero, y := Nat.zero }

    -- My own version
    def natOrigin : PPoint Nat :=
        PPoint.mk Nat.zero Nat.zero
#+end_src

Receiving a Type as argument:
#+begin_src lean4
    def replaceX (Œ± : Type) (point : PPoint Œ±) (newX : Œ±) : PPoint Œ± :=
        { point with x := newX }
#+end_src

Look how cool is match inside the types <3:
#+begin_src lean4
    inductive Sign where
        | pos
        | neg

    def posOrNegThree (s : Sign) : match s with | Sign.pos => Nat | Sign.neg => Int :=
      match s with
        | Sign.pos => (3 : Nat)
        | Sign.neg => (-3 : Int)
#+end_src

[question?] --> How do i should even deal with this type of return? Because
It's not even "Either".

**** Linked Lists
" Lists are written in square brackets. For instance, a list that contains the prime numbers less than 10 can be written:"
#+begin_src lean4
    def primesUnder10 : List Nat := [2, 3, 5, 7]
#+end_src

Behind the scenes, List is an inductive datatype, defined like this:
#+begin_src lean4
    inductive List (Œ± : Type) where
      | nil  : List Œ±
      | cons : Œ± ‚Üí List Œ± ‚Üí List Œ±
#+end_src

Ok, this looks ugly:
#+begin_src lean4
    def explicitPrimesUnder10 : List Nat :=
      List.cons 2 (List.cons 3 (List.cons 5 (List.cons 7 List.nil)))
#+end_src

Soo.. look at this lenght:
#+begin_src lean4
    def length (Œ± : Type) (xs' : List Œ±) : Nat :=
      match xs' with
      | List.nil       => Nat.zero
      | List.cons x xs => Nat.succ (length Œ± ys)
#+end_src

"To make it easier to read functions on lists, the bracket notation [] can be used to pattern-match against nil, and an infix :: can be used in place of cons:"
#+begin_src lean4
    def length (Œ± : Type) (xs : List Œ±) : Nat :=
      match xs with
      | [] => 0
      | y :: ys => Nat.succ (length Œ± ys)
#+end_src

**** Implicit Arguments
Using "{}" instead of "()" should make the argument implicit somehow.
Look at this:
#+begin_src lean4
    def length {Œ± : Type} (xs : List Œ±) : Nat :=
      match xs with
      | [] => 0
      | y :: ys => Nat.succ (length ys)
#+end_src

And now we can do
#+begin_src lean4
   #eval length [1, 2, 3]
#+end_src

,instead of
#+begin_src lean4
    #eval length Nat [1, 2, 3]
#+end_src

We can also do this way, btw
(by using the std lib):
#+begin_src lean4
   #eval [1, 2, 3].length
#+end_src

**** More Built-In Datatypes
"In addition to lists, Lean's standard library contains a number of other structures and inductive datatypes that can be used in a variety of contexts."

***** Option
It's basically the "Maybe" type from Haskell.
#+begin_src lean4
    inductive Option (Œ± : Type) : Type where
      | none           : Option Œ±
      | some (val : Œ±) : Option Œ±
#+end_src

This text talk about having layers of optionality:
"The Option type is very similar to nullable types in languages like C# and Kotlin, but it is not identical. In these languages, if a type (say, Boolean) always refers to actual values of the type (true and false), the type Boolean? or Nullable<Boolean> additionally admits the null value. Tracking this in the type system is very useful: the type checker and other tooling can help programmers remember to check for null, and APIs that explicitly describe nullability through type signatures are more informative than ones that don't. However, these nullable types differ from Lean's Option in one very important way, which is that they don't allow multiple layers of optionality. Option (Option Int) can be constructed with none, some none, or some (some 360). C#, on the other hand, forbids multiple layers of nullability by only allowing ? to be added to non-nullable types, while Kotlin treats T?? as being equivalent to T?. This subtle difference is rarely relevant in practice, but it can matter from time to time."

U can use '?' in a function name, look at this:
#+begin_src lean4
    def List.head? {Œ± : Type} (xs : List Œ±) : Option Œ± :=
      match xs with
        | []     => none
        | y :: _ => some y
#+end_src

"Using underscores instead of names is a way to clearly communicate to readers that part of the input is ignored." For more detail's:
****** Informative:
"The question mark is part of the name, and is not related to the use of question marks to indicate nullable types in C# or Kotlin. In the definition of List.head?, an underscore is used to represent the tail of the list. In patterns, underscores match anything at all, but do not introduce variables to refer to the matched data. Using underscores instead of names is a way to clearly communicate to readers that part of the input is ignored."

***** Prod
It's basically the "Pair", because we're inside the type cat.
#+begin_src lean4
    structure Prod (Œ± : Type) (Œ≤ : Type) : Type where
      fst : Œ±
      snd : Œ≤
#+end_src

About confort syntax:
#+begin_src lean4
    -- Better
    def fives : String √ó Int := { fst := "five", snd := 5 }
    -- A way better:
    def fives : String √ó Int := ("five", 5)
#+end_src

****** About syntax associativity:
"Both notations are right-associative. This means that the following definitions are equivalent:"

#+begin_src lean4
  -- The
    def sevens : String √ó Int √ó Nat := ("VII", 7, 4 + 3)
  -- Is acctualy
    def sevens : String √ó (Int √ó Nat) := ("VII", (7, 4 + 3))
#+end_src

"In other words, all products of more than two types, and their corresponding constructors, are actually nested products and nested pairs behind the scenes."
****** A good advice:
"Many applications are best served by defining their own structures, even for simple cases like Point, because using domain terminology can make it easier to read the code. Additionally, defining structure types helps catch more errors by assigning different types to different domain concepts, preventing them from being mixed up."

***** Sum
"Values of type Sum Œ± Œ≤ are either the constructor inl applied to a value of type Œ± or the constructor inr applied to a value of type Œ≤:"
#+begin_src lean4
    inductive Sum (Œ± : Type) (Œ≤ : Type) : Type where
      | inl : Œ± ‚Üí Sum Œ± Œ≤
      | inr : Œ≤ ‚Üí Sum Œ± Œ≤
#+end_src

Another notation (wrost than the simplier "+")
#+begin_src lean4
    def PetName : Type := String ‚äï String
#+end_src

Example:
#+begin_src lean4
    def howManyDogs (pets : List PetName) : Nat :=
      match pets with
      | []                    => 0
      | Sum.inl _ :: morePets => howManyDogs morePets + 1
      | Sum.inr _ :: morePets => howManyDogs morePets
#+end_src

***** Unit
Just like it should be:
#+begin_src lean4
    inductive Unit : Type where
      | unit : Unit
#+end_src

To the unique member of the "Unit" type, u can also call it by
the classical "()".

***** Empty
This should be fine:
#+begin_src lean4
    inductive Empty where
    #check Empty
#+end_src

"The Empty datatype has no constructors whatsoever. Thus, it indicates unreachable code, because no series of calls can ever terminate with a value at type Empty.

Empty is not used nearly as often as Unit. However, it is useful in some specialized contexts. Many polymorphic datatypes do not use all of their type arguments in all of their constructors. For instance, Sum.inl and Sum.inr each use only one of Sum's type arguments. Using Empty as one of the type arguments to Sum can rule out one of the constructors at a particular point in a program. This can allow generic code to be used in contexts that have additional restrictions."
*** Additional Conveniences
**** Automatic Implicit Arguments
"When writing polymorphic functions in Lean, it is typically not necessary to list all the implicit arguments."

So, that definition:
#+begin_src lean4
    def length {Œ± : Type} (xs : List Œ±) : Nat :=
      match xs with
      | []      => 0
      | y :: ys => Nat.succ (length ys)
#+end_src

Can be written this way:
#+begin_src lean4
    def length (xs : List Œ±) : Nat :=
      match xs with
      | []      => 0
      | y :: ys => Nat.succ (length ys)
#+end_src

**** Pattern-Matching Definitions
"When defining functions with def, it is quite common to name an argument and then immediately
use it with pattern matching. For instance, in length, the argument xs is used only in match.
In these situations, the cases of the match expression can be written directly, without naming the argument at all."

Example:
#+begin_src lean4
    def length : List Œ± ‚Üí Nat
      | []      => 0
      | y :: ys => Nat.succ (length ys)
#+end_src

"This syntax can also be used to define functions that take more than one argument. In this case,
their patterns are separated by commas."

Example:
#+begin_src lean4
    def drop : Nat ‚Üí List Œ± ‚Üí List Œ±
      | Nat.zero  , xs      => xs
      | _         , []      => []
      | Nat.succ n, x :: xs => drop n xs
#+end_src

"Named arguments and patterns can also be used in the same definition."
#+begin_src lean4
    def fromOption (default : Œ±) : Option Œ± ‚Üí Œ±
      | none   => default
      | some x => x
#+end_src

"This function is called Option.getD in the standard library,
  and can be called with dot notation", btw.

#+begin_src lean4
    #eval (some "salmonberry").getD "" --> "salmonberry"
    #eval none.getD ""                 --> ""
#+end_src

**** Local Definitions
"In Lean, the result of the recursive call can be named, and thus saved, using let. Local definitions with let resemble top-level definitions with def: it takes a name to be locally defined, arguments if desired, a type signature, and then a body following :=. After the local definition, the expression in which the local definition is available (called the body of the let-expression) must be on a new line, starting at a column in the file that is less than or equal to that of the let keyword. For instance, let can be used in unzip like this:"
#+begin_src lean4
    def unzip : List (Œ± √ó Œ≤) ‚Üí List Œ± √ó List Œ≤
      | []            => ([], [])
      | (x, y) :: xys =>
        let unzipped : List Œ± √ó List Œ≤ := unzip xys
        (x :: unzipped.fst, y :: unzipped.snd)
#+end_src

"To use let on a single line, separate the local definition from the body with a semicolon."

"Local definitions with let may also use pattern matching when one pattern is enough to match all cases of a datatype. In the case of unzip, the result of the recursive call is a pair. Because pairs have only a single constructor, the name unzipped can be replaced with a pair pattern:"
#+begin_src lean4
    def unzip : List (Œ± √ó Œ≤) ‚Üí List Œ± √ó List Œ≤
      | [] => ([], [])
      | (x, y) :: xys =>
        let (xs, ys) : List Œ± √ó List Œ≤ := unzip xys
        (x :: xs, y :: ys)
#+end_src

NEW FEATURE:
"The biggest difference between let and def is that recursive let definitions must be explicitly indicated by writing let rec. For instance, one way to reverse a list involves a recursive helper function, as in this definition:"
#+begin_src lean4
    def reverse (xs : List Œ±) : List Œ± :=
      let rec helper : List Œ± ‚Üí List Œ± ‚Üí List Œ±
        | [], soFar => soFar
        | y :: ys, soFar => helper ys (y :: soFar)
      helper xs []
#+end_src

**** Type Inference

**** Simultaneous Matching
**** Natural Number Patterns
**** Anonymous Functions
**** Namespaces
**** if let
**** Positional Structure Arguments
**** String Interpolation



*** "Summary"

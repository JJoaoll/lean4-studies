* Functional Programming in Lean
** Getting to know
*** Text resume
Lean4 does have a repl integrated with the LSP enviroment.

**** POO
This text talks so much about POO that hurt's me. I can't get so much POO anymore.

*** Evaluating
U should use the `#eval` to evaluate, such as this example show us:
#+begin_src lean4
  #eval 1 + 2
#+end_src

Also the function application works just like in Haskell.
(üîç) ~ So, i've just figured out that lean4 is a strict language, not a strict one. What a shame!
*** Types
When necessary, u can use type coercions with ":"
#+begin_src lean4
    #eval (1 + 2 : Nat)
    -- So look this:
    #eval  1 - 2        -->  0 : Nat
    #eval (1 - 2 : Int) --> -1 : Int
#+end_src

As u can check the values with  `#eval`
u also can check the types with `#check`
#+begin_src lean4
    #check (1 - 2 : Int)  --> 1 - 2 : Int (without performing the operation.)
#+end_src

*** Functions and Definitions
to definitions, use `def`, like:
#+begin_src lean4
    def hello := "Hello"
#+end_src

Note how great the `:=` fits for assignments instead of `=`.
If u wanna pick the type too, u can do it like this:
#+begin_src lean4
    def lean : String := "Lean"
#+end_src

When it comes to define a function, there are a variaty of ways to do that.
The simpliest one (they say it):
#+begin_src lean4
    def succ (n : Nat) : Nat := n + 1
    -- or:
    def pred (n : Nat) : Nat :=
        n - 1
#+end_src


Look this another one with more arguments:
#+begin_src lean4
    def maximum (n : Nat) (k : Nat) : Nat :=
      if n < k then
        k
      else n
#+end_src

Lean4 does use currying as default.
(my exercises are in somewhere but it's not my intent to share them :P)

**** Defining Types:
U use the same `def` keyword just like with the values (including functions)
#+begin_src lean4
    def Str  : Type := String
    def aStr : Str  := "Look at me, i'm a real String!"
#+end_src

some explanation about "aStr" definition:
"The reason this works is that types follow the same rules as the rest of Lean. Types are expressions,
and in an expression, a defined name can be replaced with its definition. Because Str has been defined
to mean String, the definition of aStr makes sense."

Something very very weird about Lean4 is that, because they want to overload number literals,
this code generates an error:
#+begin_src lean4
    def NaturalNumber : Type := Nat
    def thirtyEight : NaturalNumber := 38

    -- failed to synthesize instance
    -- OfNat NaturalNumber 38
#+end_src

But it works this way:
#+begin_src lean4
    def thirtyEight : NaturalNumber := (38 : Nat)
#+end_src

why?
"One way to work around this limitation is by providing the type Nat on the right-hand side of the definition, causing Nat's overloading rules to be used for 38:

The definition is still type-correct because NaturalNumber is the same type as Nat‚Äîby definition!"

But don't worry about it, we can see the light here:
"Another solution is to define an overloading for NaturalNumber that works equivalently to the one for Nat. This requires more advanced features of Lean, however."

Finally we have some "abbrev" like here:
#+begin_src lean4
    abbrev N : Type := Nat
    def thirtyNine : N := 39
    -- works well
#+end_src

**** Question:
whats a "foldable | unfoldable | folded | unfolded" definitions?

*** Structures
So they're basically product types..
#+begin_src lean4
    structure Point where
      x : Float
      y : Float
    deriving Repr

    def origin : Point := { x := 0.0, y := 0.0 }
#+end_src

Note that the deriving works as the `Show` in haskell.
When u call the "#eval", it call's the "repr". Look's like
we're gonna discover TypeClasses again..

About extracting things out of products we have:
#+begin_src lean4
    #eval origin.x
    #eval origin.y

    def addPoints (p1 : Point) (p2 : Point) : Point :=
        { x := p1.x + p2.x, y := p1.y + p2.y }

    structure Point3D where
        x : Float
        y : Float
        z : Float
    deriving Repr

    def origin3D : Point3D :=
        { x := 0.0, y := 0.0, z := 0.0 }
#+end_src

"To make programs more concise, Lean also allows the structure type annotation inside the curly braces."
#+begin_src lean4
    #check { x := 0.0, y := 0.0 : Point}
#+end_src

Another convenient syntax is:
#+begin_src lean4
    -- default
    def zeroX (p : Point) : Point :=
        { x := 0, y := p.y }
    -- with syntax
    def zeroX (p : Point) : Point :=
        { p with x := 0 }
#+end_src

With this syntax, some issues about refactoring code, e.g., adding new
new columns to a struct would not implie that u're refactoring every
single function that does things like above.

**** Structure constructor
So.. In Lean4, ure forced to use the "mk" thing that
u could avoid in Haskell after get some maturity..
#+begin_src lean4
    #check Point.mk 1.5 2.8
      --> { x := 1.5, y := 2.8 } : Point
#+end_src
It's just exacly how a constructor should be in a product type,
but forcing u to use de `(_.mk)` syntax, and what's ok.

- Fine, i was wrong. And the default.. Nice one, lean, nice one.
look at that:
#+begin_src lean4
    structure Point where
        point ::
        x : Float
        y : Float
    deriving Repr
#+end_src

Some notes about 'behind-the-scenes':
"In fact, just as the curly-braced structure construction syntax is converted to a call to the structure's constructor behind the scenes, the syntax p1.x in the prior definition of addPoints is converted into a call to the Point.x accessor. That is, #eval origin.x and #eval Point.x origin both yield"

LOOK AT THIS!!:
    Accessor dot notation is usable with more than just structure fields. It can also be used for functions that take any number of arguments. More generally, accessor notation has the form TARGET.f ARG1 ARG2 .... If TARGET has type T, the function named T.f is called. TARGET becomes its leftmost argument of type T, which is often but not always the first one, and ARG1 ARG2 ... are provided in order as the remaining arguments. For instance, String.append can be invoked from a string with accessor notation, even though String is not a structure with an append field.

#+begin_src lean4
    #eval "one string".append " and another"
#+end_src

(question?) - how the parenthesis works with `#eval` and `#check`?

*** Datatypes, Patterns and Recursion
It's module starts presenting what's a sum and a product of types in a
very simple and didactic way.

Also, the concept "inductive data types" were explained in this short-text:
"Datatypes that allow choices are called sum types and datatypes that can include instances of themselves are called recursive datatypes. Recursive sum types are called inductive datatypes, because mathematical induction may be used to prove statements about them. When programming, inductive datatypes are consumed through pattern matching and recursive functions."

But also look this definition:
#+begin_src lean4
    inductive Bool where
      | false : Bool
      | true  : Bool
#+end_src

About classical ones, we have:
#+begin_src lean4
    inductive Nat where
      | zero : Nat
      | succ (n : Nat) : Nat
#+end_src

**** Pattern Matching
Examples:
#+begin_src lean4
    def isZero (n : Nat) : Bool :=
        match n with
        | Nat.zero   => true
        | Nat.succ k => false

    def pred (n : Nat) : Nat :=
        match n with
        | Nat.zero   => Nat.zero
        | Nat.succ k => k
#+end_src

U can match with products just like sums (...)
#+begin_src lean4
    def depth (p : Point3D) : Float :=
        match p with
        | { x:= h, y := w, z := d } => d

    -- Better:
    def depth (p : Point3D) : Float :=
        match p with
        | Point3D.mk _ _ d => d
#+end_src

**** Recursive Functions
Examples:
#+begin_src lean4
    def even (n : Nat) : Bool :=
        match n with
        | Nat.zero   => true
        | Nat.succ k => not (even k)
#+end_src

"Lean ensures by default that every recursive function will eventually reach a base case"
#+begin_src lean4
    -- error:
    def evenLoops (n : Nat) : Bool :=
        match n with
        | Nat.zero   => true
        | Nat.succ k => not (evenLoops n)
#+end_src

Mensagem do erro:
"fail to show termination for
  evenLoops
with errors
structural recursion cannot be used

well-founded recursion cannot be used, 'evenLoops' does not take any (non-fixed) arguments
"

Another classical's:
#+begin_src lean4
    def plus (n : Nat) (k : Nat) : Nat :=
        match k with
        | Nat.zero    => n
        | Nat.succ k' => Nat.succ (plus n k')

    def times (n : Nat) (k : Nat) : Nat :=
        match k with
        | Nat.zero    => Nat.zero
        | Nat.succ k' => plus n (times n k')

    def monus* (n : Nat) (k : Nat) : Nat :=
        match k with
        | Nat.zero    => n
        | Nat.succ k' => pred (minus n k')
#+end_src

Algumas coisas sobre a termina√ß√£o da quot foram tratadas,
mas s√≥ ser√£o `terminadas` no √∫ltimo cap√≠tulo, portanto, nada
a mencionar por aqui.

*** Polymorphism
Look this amazing generalized point:
#+begin_src lean4
    structure PPoint (Œ± : Type) where
        x : Œ±
        y : Œ±
    deriving Repr
#+end_src

Usage example:
#+begin_src lean4
    def natOrigin : PPoint Nat :=
        { x := Nat.zero, y := Nat.zero }

    -- My own version
    def natOrigin : PPoint Nat :=
        PPoint.mk Nat.zero Nat.zero
#+end_src

Receiving a Type as argument:
#+begin_src lean4
    def replaceX (Œ± : Type) (point : PPoint Œ±) (newX : Œ±) : PPoint Œ± :=
        { point with x := newX }
#+end_src

Look how cool is match inside the types <3:
#+begin_src lean4
    inductive Sign where
        | pos
        | neg

    def posOrNegThree (s : Sign) : match s with | Sign.pos => Nat | Sign.neg => Int :=
      match s with
        | Sign.pos => (3 : Nat)
        | Sign.neg => (-3 : Int)
#+end_src

[question?] --> How do i should even deal with this type of return? Because
It's not even "Either".

**** Linked Lists
" Lists are written in square brackets. For instance, a list that contains the prime numbers less than 10 can be written:"
#+begin_src lean4
    def primesUnder10 : List Nat := [2, 3, 5, 7]
#+end_src

Behind the scenes, List is an inductive datatype, defined like this:
#+begin_src lean4
    inductive List (Œ± : Type) where
      | nil  : List Œ±
      | cons : Œ± ‚Üí List Œ± ‚Üí List Œ±
#+end_src

Ok, this looks ugly:
#+begin_src lean4
    def explicitPrimesUnder10 : List Nat :=
      List.cons 2 (List.cons 3 (List.cons 5 (List.cons 7 List.nil)))
#+end_src

Soo.. look at this lenght:
#+begin_src lean4
    def length (Œ± : Type) (xs' : List Œ±) : Nat :=
      match xs' with
      | List.nil       => Nat.zero
      | List.cons x xs => Nat.succ (length Œ± ys)
#+end_src

"To make it easier to read functions on lists, the bracket notation [] can be used to pattern-match against nil, and an infix :: can be used in place of cons:"
#+begin_src lean4
    def length (Œ± : Type) (xs : List Œ±) : Nat :=
      match xs with
      | [] => 0
      | y :: ys => Nat.succ (length Œ± ys)
#+end_src

**** Implicit Arguments
Using "{}" instead of "()" should make the argument implicit somehow.
Look at this:
#+begin_src lean4
    def length {Œ± : Type} (xs : List Œ±) : Nat :=
      match xs with
      | [] => 0
      | y :: ys => Nat.succ (length ys)
#+end_src

And now we can do
#+begin_src lean4
   #eval length [1, 2, 3]
#+end_src

,instead of
#+begin_src lean4
    #eval length Nat [1, 2, 3]
#+end_src

We can also do this way, btw
(by using the std lib):
#+begin_src lean4
   #eval [1, 2, 3].length
#+end_src

**** More Built-In Datatypes
"In addition to lists, Lean's standard library contains a number of other structures and inductive datatypes that can be used in a variety of contexts."

***** Option
It's basically the "Maybe" type from Haskell.
#+begin_src lean4
    inductive Option (Œ± : Type) : Type where
      | none           : Option Œ±
      | some (val : Œ±) : Option Œ±
#+end_src

This text talk about having layers of optionality:
"The Option type is very similar to nullable types in languages like C# and Kotlin, but it is not identical. In these languages, if a type (say, Boolean) always refers to actual values of the type (true and false), the type Boolean? or Nullable<Boolean> additionally admits the null value. Tracking this in the type system is very useful: the type checker and other tooling can help programmers remember to check for null, and APIs that explicitly describe nullability through type signatures are more informative than ones that don't. However, these nullable types differ from Lean's Option in one very important way, which is that they don't allow multiple layers of optionality. Option (Option Int) can be constructed with none, some none, or some (some 360). C#, on the other hand, forbids multiple layers of nullability by only allowing ? to be added to non-nullable types, while Kotlin treats T?? as being equivalent to T?. This subtle difference is rarely relevant in practice, but it can matter from time to time."

U can use '?' in a function name, look at this:
#+begin_src lean4
    def List.head? {Œ± : Type} (xs : List Œ±) : Option Œ± :=
      match xs with
        | []     => none
        | y :: _ => some y
#+end_src

"Using underscores instead of names is a way to clearly communicate to readers that part of the input is ignored." For more detail's:
****** Informative:
"The question mark is part of the name, and is not related to the use of question marks to indicate nullable types in C# or Kotlin. In the definition of List.head?, an underscore is used to represent the tail of the list. In patterns, underscores match anything at all, but do not introduce variables to refer to the matched data. Using underscores instead of names is a way to clearly communicate to readers that part of the input is ignored."

***** Prod
It's basically the "Pair", because we're inside the type cat.
#+begin_src lean4
    structure Prod (Œ± : Type) (Œ≤ : Type) : Type where
      fst : Œ±
      snd : Œ≤
#+end_src

About confort syntax:
#+begin_src lean4
    -- Better
    def fives : String √ó Int := { fst := "five", snd := 5 }
    -- A way better:
    def fives : String √ó Int := ("five", 5)
#+end_src

****** About syntax associativity:
"Both notations are right-associative. This means that the following definitions are equivalent:"

#+begin_src lean4
  -- The
    def sevens : String √ó Int √ó Nat := ("VII", 7, 4 + 3)
  -- Is acctualy
    def sevens : String √ó (Int √ó Nat) := ("VII", (7, 4 + 3))
#+end_src

"In other words, all products of more than two types, and their corresponding constructors, are actually nested products and nested pairs behind the scenes."
****** A good advice:
"Many applications are best served by defining their own structures, even for simple cases like Point, because using domain terminology can make it easier to read the code. Additionally, defining structure types helps catch more errors by assigning different types to different domain concepts, preventing them from being mixed up."

***** Sum
"Values of type Sum Œ± Œ≤ are either the constructor inl applied to a value of type Œ± or the constructor inr applied to a value of type Œ≤:"
#+begin_src lean4
    inductive Sum (Œ± : Type) (Œ≤ : Type) : Type where
      | inl : Œ± ‚Üí Sum Œ± Œ≤
      | inr : Œ≤ ‚Üí Sum Œ± Œ≤
#+end_src

Another notation (wrost than the simplier "+")
#+begin_src lean4
    def PetName : Type := String ‚äï String
#+end_src

Example:
#+begin_src lean4
    def howManyDogs (pets : List PetName) : Nat :=
      match pets with
      | []                    => 0
      | Sum.inl _ :: morePets => howManyDogs morePets + 1
      | Sum.inr _ :: morePets => howManyDogs morePets
#+end_src

***** Unit
Just like it should be:
#+begin_src lean4
    inductive Unit : Type where
      | unit : Unit
#+end_src

To the unique member of the "Unit" type, u can also call it by
the classical "()".

***** Empty
This should be fine:
#+begin_src lean4
    inductive Empty where
    #check Empty
#+end_src

"The Empty datatype has no constructors whatsoever. Thus, it indicates unreachable code, because no series of calls can ever terminate with a value at type Empty.

Empty is not used nearly as often as Unit. However, it is useful in some specialized contexts. Many polymorphic datatypes do not use all of their type arguments in all of their constructors. For instance, Sum.inl and Sum.inr each use only one of Sum's type arguments. Using Empty as one of the type arguments to Sum can rule out one of the constructors at a particular point in a program. This can allow generic code to be used in contexts that have additional restrictions."
*** Additional Conveniences
**** Automatic Implicit Arguments
"When writing polymorphic functions in Lean, it is typically not necessary to list all the implicit arguments."

So, that definition:
#+begin_src lean4
    def length {Œ± : Type} (xs : List Œ±) : Nat :=
      match xs with
      | []      => 0
      | y :: ys => Nat.succ (length ys)
#+end_src

Can be written this way:
#+begin_src lean4
    def length (xs : List Œ±) : Nat :=
      match xs with
      | []      => 0
      | y :: ys => Nat.succ (length ys)
#+end_src

**** Pattern-Matching Definitions
"When defining functions with def, it is quite common to name an argument and then immediately
use it with pattern matching. For instance, in length, the argument xs is used only in match.
In these situations, the cases of the match expression can be written directly, without naming the argument at all."

Example:
#+begin_src lean4
    def length : List Œ± ‚Üí Nat
      | []      => 0
      | y :: ys => Nat.succ (length ys)
#+end_src

"This syntax can also be used to define functions that take more than one argument. In this case,
their patterns are separated by commas."

Example:
#+begin_src lean4
    def drop : Nat ‚Üí List Œ± ‚Üí List Œ±
      | Nat.zero  , xs      => xs
      | _         , []      => []
      | Nat.succ n, x :: xs => drop n xs
#+end_src

"Named arguments and patterns can also be used in the same definition."
#+begin_src lean4
    def fromOption (default : Œ±) : Option Œ± ‚Üí Œ±
      | none   => default
      | some x => x
#+end_src

"This function is called Option.getD in the standard library,
  and can be called with dot notation", btw.

#+begin_src lean4
    #eval (some "salmonberry").getD "" --> "salmonberry"
    #eval none.getD ""                 --> ""
#+end_src

**** Local Definitions
"In Lean, the result of the recursive call can be named, and thus saved, using let. Local definitions with let resemble top-level definitions with def: it takes a name to be locally defined, arguments if desired, a type signature, and then a body following :=. After the local definition, the expression in which the local definition is available (called the body of the let-expression) must be on a new line, starting at a column in the file that is less than or equal to that of the let keyword. For instance, let can be used in unzip like this:"
#+begin_src lean4
    def unzip : List (Œ± √ó Œ≤) ‚Üí List Œ± √ó List Œ≤
      | []            => ([], [])
      | (x, y) :: xys =>
        let unzipped : List Œ± √ó List Œ≤ := unzip xys
        (x :: unzipped.fst, y :: unzipped.snd)
#+end_src

"To use let on a single line, separate the local definition from the body with a semicolon."

"Local definitions with let may also use pattern matching when one pattern is enough to match all cases of a datatype. In the case of unzip, the result of the recursive call is a pair. Because pairs have only a single constructor, the name unzipped can be replaced with a pair pattern:"
#+begin_src lean4
    def unzip : List (Œ± √ó Œ≤) ‚Üí List Œ± √ó List Œ≤
      | [] => ([], [])
      | (x, y) :: xys =>
        let (xs, ys) : List Œ± √ó List Œ≤ := unzip xys
        (x :: xs, y :: ys)
#+end_src

NEW FEATURE:
"The biggest difference between let and def is that recursive let definitions must be explicitly indicated by writing let rec. For instance, one way to reverse a list involves a recursive helper function, as in this definition:"
#+begin_src lean4
    def reverse (xs : List Œ±) : List Œ± :=
      let rec helper : List Œ± ‚Üí List Œ± ‚Üí List Œ±
        | [], soFar => soFar
        | y :: ys, soFar => helper ys (y :: soFar)
      helper xs []
#+end_src

**** Type Inference
"In many situations, Lean can automatically determine an expression's type. In these cases, explicit types may be omitted from both top-level definitions (with def) and local definitions (with let). For instance, the recursive call to unzip does not need an annotation:"
#+begin_src lean4
    def unzip : List (Œ± √ó Œ≤) ‚Üí List Œ± √ó List Œ≤
      | []            => ([], [])
      | (x, y) :: xys =>
        let unzipped := unzip xys
        (x :: unzipped.fst, y :: unzipped.snd)
#+end_src

In deed, it could even be like this:
#+begin_src lean4
    def unnzip : List (Œ± √ó Œ≤) ‚Üí List Œ± √ó List Œ≤
      | []            => ([], [])
      | (x, y) :: xys =>
        let (xs, ys) := unzip xys
        (x :: xs, y :: ys)
#+end_src

"Omitting the return type for unzip is possible when using an explicit match expression:"
#+begin_src lean4
    def unzip (pairs : List (Œ± √ó Œ≤)) :=
      match pairs with
      | [] => ([], [])
      | (x, y) :: xys =>
        let unzipped := unzip xys
        (x :: unzipped.fst, y :: unzipped.snd)
#+end_src

"Missing type annotations can give confusing error messages. Omitting all types from the definition of unzip:"
#+begin_src lean4
    def unzip pairs :=
      match pairs with
      | [] => ([], [])
      | (x, y) :: xys =>
        let unzipped := unzip xys
        (x :: unzipped.fst, y :: unzipped.snd)
#+end_src

It generate this error message:
#+begin_src error
    invalid match-expression, pattern contains metavariables
      []
#+end_src

"This is because match needs to know the type of the value being inspected, but that type was not available."

"Even some very simple programs require type annotations. For instance, the identity function just returns whatever argument it is passed. With argument and type annotations, it looks like this:"
#+begin_src lean4
    def id (x : Œ±) : Œ± := x
#+end_src

"Lean is capable of determining the return type on its own:"
#+begin_src lean4
    def id (x : Œ±) := x
#+end_src

"Omitting the argument type, however, causes an error:"
#+begin_src lean4
    def id x := x --> (!) failed to infer binder type
#+end_src

**** Simultaneous Matching
"Pattern-matching expressions, just like pattern-matching definitions, can match on multiple values at once. "

Look at this:
#+begin_src lean4
    def drop (n : Nat) (xs : List Œ±) : List Œ± :=
      match n, xs with
      | Nat.zero   , ys      => ys
      | _          , []      => []
      | Nat.succ n , y :: ys => drop n ys
#+end_src

**** Natural Number Patterns
"Just as there is special syntax to make list patterns more readable
than using List.cons and List.nil directly, natural numbers can be
matched using literal numbers and +. For instance, even can also be
defined like this:"
#+begin_src lean4
    def even : Nat ‚Üí Bool
      | 0     => true
      | n + 1 => not (even n)
#+end_src

The explicit patterns in halve, which divides a Nat by two and drops the remainder:
#+begin_src lean4
    def halve : Nat ‚Üí Nat
      | Nat.zero => 0
      | Nat.succ Nat.zero => 0
      | Nat.succ (Nat.succ n) => halve n + 1
#+end_src

can be replaced by numeric literals and +:
#+begin_src lean4
    def halve : Nat ‚Üí Nat
      | 0     => 0
      | 1     => 0
      | n + 2 => halve n + 1
#+end_src

"When using this syntax, the second argument to + should always be a literal Nat. Even though addition is commutative."

**** Anonymous Functions
The both can be used:
#+begin_src lean4
    #check fun
      | 0 => none
      | n + 1 => some n
    #check Œª
      | 0 => none
      | n + 1 => some n
#+end_src

So, basicaly: fun = Œª.
It's a bit more usual to use "fun" instead of "Œª", btw.

Awelsome syntax gift:
"When an anonymous function is very simple, like fun x => x + 1, the syntax for creating the function can be fairly verbose. In that particular example, six non-whitespace characters are used to introduce the function, and its body consists of only three non-whitespace characters. For these simple cases, Lean provides a shorthand. In an expression surrounded by parentheses, a centered dot character ¬∑ can stand for an argument, and the expression inside the parentheses becomes the function's body. That particular function can also be written (¬∑ + 1)."

"The centered dot always creates a function out of the closest surrounding set of parentheses. For instance, (¬∑ + 5, 3) is a function that returns a pair of numbers, while ((¬∑ + 5), 3) is a pair of a function and a number. If multiple dots are used, then they become arguments from left to right:"

#+begin_src lean4
    (¬∑ , ¬∑) 1 2
    ===>
    (1, ¬∑) 2
    ===>
    (1, 2)
#+end_src

**** Namespaces
Each name in Lean occurs in a namespace, which is a collection of names. Names are placed in namespaces using ., so List.map is the name map in the List namespace.

Names can be directly defined within a namespace. For instance, the name double can be defined in the Nat namespace:
#+begin_src lean4
    def Nat.double (x : Nat) : Nat := x + x
#+end_src

Because Nat is also the name of a type, dot notation is available to call Nat.double on expressions with type Nat:
#+begin_src lean4
    #eval (4 : Nat).double
#+end_src

In addition to defining names directly in a namespace, a sequence of declarations can be placed in a namespace using the namespace and end commands. For instance, this defines triple and quadruple in the namespace NewNamespace:
#+begin_src lean4
    namespace NewNamespace
    def triple    (x : Nat) : Nat := 3 * x
    def quadruple (x : Nat) : Nat := 2 * x + 2 * x
    end NewNamespace
#+end_src

"Namespaces may be opened, which allows the names in them to be used without explicit qualification. Writing open MyNamespace in before an expression causes the contents of MyNamespace to be available in the expression. For example, timesTwelve uses both quadruple and triple after opening NewNamespace:"
#+begin_src lean4
   def timesTwelve (x : Nat) :=
     open NewNamespace in
     quadruple (triple x)
#+end_src

Namespaces can also be opened prior to a command. This allows all parts of the command to refer to the contents of the namespace, rather than just a single expression. To do this, place the open ... in prior to the command.
#+begin_src lean4
    open NewNamespace in
    #check quadruple
#+end_src

Important:
"Function signatures show the name's full namespace. Namespaces may additionally be opened for all following commands for the rest of the file. To do this, simply omit the in from a top-level usage of open."

**** if let
a function that recognizes string elements and extracts their contents can be written:
#+begin_src lean4
    def Inline.string? (inline : Inline) : Option String :=
      match inline with
      | Inline.string s => some s
      | _               => none
#+end_src

An alternative way of writing this function's body uses if together with let:
#+begin_src lean4
    def Inline.string? (inline : Inline) : Option String :=
      if let Inline.string s := inline then
        some s
      else none
#+end_src

It really look like some `instanceOf`'s.. Ugly, yeah!

**** Positional Structure Arguments
With some context, like definitions, because
Structures are essencialy tupples, we can write
it like this:
#+begin_src lean4
    #eval (‚ü®1, 2‚ü© : Point)
#+end_src
**** String Interpolation
"In Lean, prefixing a string with s! triggers interpolation, where expressions contained in curly braces inside the string are replaced with their values. This is similar to f-strings in Python and $-prefixed strings in C#. For instance,"
#+begin_src lean4
    #eval s!"three fives is {NewNamespace.triple 5}"
    --> "three fives is 15"
#+end_src

*** TODO "Summary"
** Hello, World!
*** Compiling
So u use `lean --rn file-name.lean` in order
to compile things.

*** The main
The main should look similar to in Haskell as bellow:
#+begin_src lean4
    def main : IO Unit := IO.println "Hello, world!"
#+end_src

*** The IO
In a first look, the usage looks pretty similar to Haskells.
#+begin_src lean4
    def main : IO Unit := do
      let stdin  ‚Üê IO.getStdin
      let stdout ‚Üê IO.getStdout

      stdout.putStrLn "How would you like to be addressed?"
      let input ‚Üê stdin.getLine
      let name := input.dropRightWhile Char.isWhitespace

      stdout.putStrLn s!"Hello, {name}!"
#+end_src

*** Build Tool's (Lake)
**** Lake intro
The standard Lean build tool is called Lake (short for "Lean Make").

"Just as Lean contains a special-purpose language for writing programs with effects (the do language), Lake contains a special-purpose language for configuring builds."

**** Creating a project
Lake new create a new project in a new directory, to create a project in an already-existing directory,
run lake init instead.

**** Special "<< name >>"
Placing guillemets around a name, as in ¬´Greeting¬ª, allow it to contain spaces or other characters that are normally not allowed in Lean names, and it allows reserved keywords such as if or def to be used as ordinary names by writing ¬´if¬ª or ¬´def¬ª. This prevents issues when the package name provided to lake new contains such characters.

**** Running the project
To build the package, run the command lake build. After a number of build commands scroll by, the
resulting binary has been placed in build/bin. Running `./build/bin/greeting` results in Hello, world!.

To me it appeared in a file inside `.lake/build/bin/`

**** Lake documentation link
https://github.com/leanprover/lean4/blob/master/src/lake/README.md



**** Lean4 as the Lider
"Additionally, Lakefiles may contain external libraries, which are libraries not written in Lean to be
statically linked with the resulting executable."

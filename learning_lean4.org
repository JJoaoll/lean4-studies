* Functional Programming in Lean
** Getting to know
*** TODO Text resume
Lean4 does have a repl integrated with the LSP enviroment.

**** POO
This text talks so much about POO that hurt's me. I can't get so much POO anymore.

*** Evaluating
U should use the `#eval` to evaluate, such as this example show us:
#+begin_src lean4
#eval 1 + 2
#+end_src

Also the function application works just like in Haskell.
(üîç) ~ So, i've just figured out that lean4 is a strict language, not a strict one. What a shame!
*** Types
When necessary, u can use type coercions with ":"
#+begin_src lean4
#eval (1 + 2 : Nat)
-- So look this:
#eval  1 - 2        -->  0 : Nat
#eval (1 - 2 : Int) --> -1 : Int
#+end_src

As u can check the values with  `#eval`
u also can check the types with `#check`
#+begin_src lean4
#check (1 - 2 : Int)  --> 1 - 2 : Int (without performing the operation.)
#+end_src

*** Functions and Definitions
to definitions, use `def`, like:
#+begin_src lean4
def hello := "Hello"
#+end_src

Note how great the `:=` fits for assignments instead of `=`.
If u wanna pick the type too, u can do it like this:
#+begin_src lean4
def lean : String := "Lean"
#+end_src

When it comes to define a function, there are a variaty of ways to do that.
The simpliest one (they say it):
#+begin_src lean4
def succ (n : Nat) : Nat := n + 1
-- or:
def pred (n : Nat) : Nat :=
  n - 1
#+end_src


Look this another one with more arguments:
#+begin_src lean4
def maximum (n : Nat) (k : Nat) : Nat :=
  if n < k then
    k
  else n
#+end_src

Lean4 does use currying as default.
(my exercises are in somewhere but it's not my intent to share them :P)

**** Defining Types:
U use the same `def` keyword just like with the values (including functions)
#+begin_src lean4
def Str  : Type := String
def aStr : Str  := "Look at me, i'm a real String!"
#+end_src

some explanation about "aStr" definition:
"The reason this works is that types follow the same rules as the rest of Lean. Types are expressions,
and in an expression, a defined name can be replaced with its definition. Because Str has been defined
to mean String, the definition of aStr makes sense."

Something very very weird about Lean4 is that, because they want to overload number literals,
this code generates an error:
#+begin_src lean4
def NaturalNumber : Type := Nat
def thirtyEight : NaturalNumber := 38
 -- failed to synthesize instance
-- OfNat NaturalNumber 38
#+end_src

But it works this way:
#+begin_src lean4
def thirtyEight : NaturalNumber := (38 : Nat)
#+end_src

why?
"One way to work around this limitation is by providing the type Nat on the right-hand side of the definition, causing Nat's overloading rules to be used for 38:

The definition is still type-correct because NaturalNumber is the same type as Nat‚Äîby definition!"

But don't worry about it, we can see the light here:
"Another solution is to define an overloading for NaturalNumber that works equivalently to the one for Nat. This requires more advanced features of Lean, however."

Finally we have some "abbrev" like here:
#+begin_src lean4
abbrev N : Type := Nat
def thirtyNine : N := 39
-- works well
#+end_src

**** Question:
whats a "foldable | unfoldable | folded | unfolded" definitions?

*** Structures
So they're basically product types..
#+begin_src lean4
structure Point where
  x : Float
  y : Float
deriving Repr

def origin : Point := { x := 0.0, y := 0.0 }
#+end_src

Note that the deriving works as the `Show` in haskell.
When u call the "#eval", it call's the "repr". Look's like
we're gonna discover TypeClasses again..

About extracting things out of products we have:
#+begin_src lean4
#eval origin.x
#eval origin.y

def addPoints (p1 : Point) (p2 : Point) : Point :=
    { x := p1.x + p2.x, y := p1.y + p2.y }

structure Point3D where
    x : Float
    y : Float
    z : Float
deriving Repr

def origin3D : Point3D :=
    { x := 0.0, y := 0.0, z := 0.0 }
#+end_src

"To make programs more concise, Lean also allows the structure type annotation inside the curly braces."
#+begin_src lean4
    #check { x := 0.0, y := 0.0 : Point}
#+end_src

Another convenient syntax is:
#+begin_src lean4
-- default
def zeroX (p : Point) : Point :=
    { x := 0, y := p.y }
-- with syntax
def zeroX (p : Point) : Point :=
    { p with x := 0 }
#+end_src

With this syntax, some issues about refactoring code, e.g., adding new
new columns to a struct would not implie that u're refactoring every
single function that does things like above.

**** Structure constructor
So.. In Lean4, ure forced to use the "mk" thing that
u could avoid in Haskell after get some maturity..
#+begin_src lean4
#check Point.mk 1.5 2.8
 --> { x := 1.5, y := 2.8 } : Point
#+end_src
It's just exacly how a constructor should be in a product type,
but forcing u to use de `(_.mk)` syntax, and what's ok.

- Fine, i was wrong. And the default.. Nice one, lean, nice one.
look at that:
#+begin_src lean4
structure Point where
  point ::
  x : Float
  y : Float
deriving Repr
#+end_src

Some notes about 'behind-the-scenes':
"In fact, just as the curly-braced structure construction syntax is converted to a call to the structure's constructor behind the scenes, the syntax p1.x in the prior definition of addPoints is converted into a call to the Point.x accessor. That is, #eval origin.x and #eval Point.x origin both yield"

LOOK AT THIS!!:
    Accessor dot notation is usable with more than just structure fields. It can also be used for functions that take any number of arguments. More generally, accessor notation has the form TARGET.f ARG1 ARG2 .... If TARGET has type T, the function named T.f is called. TARGET becomes its leftmost argument of type T, which is often but not always the first one, and ARG1 ARG2 ... are provided in order as the remaining arguments. For instance, String.append can be invoked from a string with accessor notation, even though String is not a structure with an append field.

#+begin_src lean4
#eval "one string".append " and another"
#+end_src

(question?) - how the parenthesis works with `#eval` and `#check`?

*** Datatypes, Patterns and Recursion
It's module starts presenting what's a sum and a product of types in a
very simple and didactic way.

Also, the concept "inductive data types" were explained in this short-text:
"Datatypes that allow choices are called sum types and datatypes that can include instances of themselves are called recursive datatypes. Recursive sum types are called inductive datatypes, because mathematical induction may be used to prove statements about them. When programming, inductive datatypes are consumed through pattern matching and recursive functions."

But also look this definition:
#+begin_src lean4
inductive Bool where
  | false : Bool
  | true  : Bool
#+end_src

About classical ones, we have:
#+begin_src lean4
inductive Nat where
  | zero : Nat
  | succ (n : Nat) : Nat
#+end_src

**** Pattern Matching
Examples:
#+begin_src lean4
def isZero (n : Nat) : Bool :=
    match n with
    | Nat.zero   => true
    | Nat.succ k => false

def pred (n : Nat) : Nat :=
    match n with
    | Nat.zero   => Nat.zero
    | Nat.succ k => k
#+end_src

U can match with products just like sums (...)
#+begin_src lean4
def depth (p : Point3D) : Float :=
    match p with
    | { x:= h, y := w, z := d } => d

-- Better:
def depth (p : Point3D) : Float :=
    match p with
    | Point3D.mk _ _ d => d
#+end_src

**** Recursive Functions
Examples:
#+begin_src lean4
def even (n : Nat) : Bool :=
    match n with
    | Nat.zero   => true
    | Nat.succ k => not (even k)
#+end_src

"Lean ensures by default that every recursive function will eventually reach a base case"
#+begin_src lean4
-- error:
def evenLoops (n : Nat) : Bool :=
    match n with
    | Nat.zero   => true
    | Nat.succ k => not (evenLoops n)
#+end_src

Mensagem do erro:
"fail to show termination for
  evenLoops
with errors
structural recursion cannot be used

well-founded recursion cannot be used, 'evenLoops' does not take any (non-fixed) arguments
"

Another classical's:
#+begin_src lean4
def plus (n : Nat) (k : Nat) : Nat :=
    match k with
    | Nat.zero    => n
    | Nat.succ k' => Nat.succ (plus n k')

def times (n : Nat) (k : Nat) : Nat :=
    match k with
    | Nat.zero    => Nat.zero
    | Nat.succ k' => plus n (times n k')

def monus* (n : Nat) (k : Nat) : Nat :=
    match k with
    | Nat.zero    => n
    | Nat.succ k' => pred (minus n k')
#+end_src

Algumas coisas sobre a termina√ß√£o da quot foram tratadas,
mas s√≥ ser√£o `terminadas` no √∫ltimo cap√≠tulo, portanto, nada
a mencionar por aqui.

*** Polymorphism
Look this amazing generalized point:
#+begin_src lean4
structure PPoint (Œ± : Type) where
  x : Œ±
  y : Œ±
deriving Repr
#+end_src

Usage example:
#+begin_src lean4
def natOrigin : PPoint Nat :=
  { x := Nat.zero, y := Nat.zero }

-- My own version
def natOrigin : PPoint Nat :=
  PPoint.mk Nat.zero Nat.zero
#+end_src

Receiving a Type as argument:
#+begin_src lean4
def replaceX (Œ± : Type) (point : PPoint Œ±) (newX : Œ±) : PPoint Œ± :=
    { point with x := newX }
#+end_src

Look how cool is match inside the types <3:
#+begin_src lean4
inductive Sign where
  | pos
  | neg

def posOrNegThree (s : Sign) : match s with | Sign.pos => Nat | Sign.neg => Int :=
  match s with
    | Sign.pos => (3 : Nat)
    | Sign.neg => (-3 : Int)
#+end_src

[question?] --> How do i should even deal with this type of return? Because
It's not even "Either".

**** Linked Lists
" Lists are written in square brackets. For instance, a list that contains the prime numbers less than 10 can be written:"
#+begin_src lean4
def primesUnder10 : List Nat := [2, 3, 5, 7]
#+end_src

Behind the scenes, List is an inductive datatype, defined like this:
#+begin_src lean4
inductive List (Œ± : Type) where
  | nil  : List Œ±
  | cons : Œ± ‚Üí List Œ± ‚Üí List Œ±
#+end_src

Ok, this looks ugly:
#+begin_src lean4
def explicitPrimesUnder10 : List Nat :=
  List.cons 2 (List.cons 3 (List.cons 5 (List.cons 7 List.nil)))
#+end_src

Soo.. look at this lenght:
#+begin_src lean4
def length (Œ± : Type) (xs' : List Œ±) : Nat :=
  match xs' with
  | List.nil       => Nat.zero
  | List.cons x xs => Nat.succ (length Œ± ys)
#+end_src

"To make it easier to read functions on lists, the bracket notation [] can be used to pattern-match against nil, and an infix :: can be used in place of cons:"
#+begin_src lean4
def length (Œ± : Type) (xs : List Œ±) : Nat :=
  match xs with
  | [] => 0
  | y :: ys => Nat.succ (length Œ± ys)
#+end_src

**** Implicit Arguments
Using "{}" instead of "()" should make the argument implicit somehow.
Look at this:
#+begin_src lean4
def length {Œ± : Type} (xs : List Œ±) : Nat :=
  match xs with
  | [] => 0
  | y :: ys => Nat.succ (length ys)
#+end_src

And now we can do
#+begin_src lean4
#eval length [1, 2, 3]
#+end_src

,instead of
#+begin_src lean4
#eval length Nat [1, 2, 3]
#+end_src

We can also do this way, btw
(by using the std lib):
#+begin_src lean4
#eval [1, 2, 3].length
#+end_src

**** More Built-In Datatypes
"In addition to lists, Lean's standard library contains a number of other structures and inductive datatypes that can be used in a variety of contexts."

***** Option
It's basically the "Maybe" type from Haskell.
#+begin_src lean4
inductive Option (Œ± : Type) : Type where
  | none           : Option Œ±
  | some (val : Œ±) : Option Œ±
#+end_src

This text talk about having layers of optionality:
"The Option type is very similar to nullable types in languages like C# and Kotlin, but it is not identical. In these languages, if a type (say, Boolean) always refers to actual values of the type (true and false), the type Boolean? or Nullable<Boolean> additionally admits the null value. Tracking this in the type system is very useful: the type checker and other tooling can help programmers remember to check for null, and APIs that explicitly describe nullability through type signatures are more informative than ones that don't. However, these nullable types differ from Lean's Option in one very important way, which is that they don't allow multiple layers of optionality. Option (Option Int) can be constructed with none, some none, or some (some 360). C#, on the other hand, forbids multiple layers of nullability by only allowing ? to be added to non-nullable types, while Kotlin treats T?? as being equivalent to T?. This subtle difference is rarely relevant in practice, but it can matter from time to time."

U can use '?' in a function name, look at this:
#+begin_src lean4
def List.head? {Œ± : Type} (xs : List Œ±) : Option Œ± :=
  match xs with
    | []     => none
    | y :: _ => some y
#+end_src

"Using underscores instead of names is a way to clearly communicate to readers that part of the input is ignored." For more detail's:
****** Informative:
"The question mark is part of the name, and is not related to the use of question marks to indicate nullable types in C# or Kotlin. In the definition of List.head?, an underscore is used to represent the tail of the list. In patterns, underscores match anything at all, but do not introduce variables to refer to the matched data. Using underscores instead of names is a way to clearly communicate to readers that part of the input is ignored."

***** Prod
It's basically the "Pair", because we're inside the type cat.
#+begin_src lean4
structure Prod (Œ± : Type) (Œ≤ : Type) : Type where
  fst : Œ±
  snd : Œ≤
#+end_src

About confort syntax:
#+begin_src lean4
-- Better
def fives : String √ó Int := { fst := "five", snd := 5 }
-- A way better:
def fives : String √ó Int := ("five", 5)
#+end_src

****** About syntax associativity:
"Both notations are right-associative. This means that the following definitions are equivalent:"

#+begin_src lean4
-- The
def sevens : String √ó Int √ó Nat := ("VII", 7, 4 + 3)
-- Is acctualy
def sevens : String √ó (Int √ó Nat) := ("VII", (7, 4 + 3))
#+end_src

"In other words, all products of more than two types, and their corresponding constructors, are actually nested products and nested pairs behind the scenes."
****** A good advice:
"Many applications are best served by defining their own structures, even for simple cases like Point, because using domain terminology can make it easier to read the code. Additionally, defining structure types helps catch more errors by assigning different types to different domain concepts, preventing them from being mixed up."

***** Sum
"Values of type Sum Œ± Œ≤ are either the constructor inl applied to a value of type Œ± or the constructor inr applied to a value of type Œ≤:"
#+begin_src lean4
inductive Sum (Œ± : Type) (Œ≤ : Type) : Type where
  | inl : Œ± ‚Üí Sum Œ± Œ≤
  | inr : Œ≤ ‚Üí Sum Œ± Œ≤
#+end_src

Another notation (wrost than the simplier "+")
#+begin_src lean4
def PetName : Type := String ‚äï String
#+end_src

Example:
#+begin_src lean4
def howManyDogs (pets : List PetName) : Nat :=
  match pets with
  | []                    => 0
  | Sum.inl _ :: morePets => howManyDogs morePets + 1
  | Sum.inr _ :: morePets => howManyDogs morePets
#+end_src

***** Unit
Just like it should be:
#+begin_src lean4
inductive Unit : Type where
  | unit : Unit
#+end_src

To the unique member of the "Unit" type, u can also call it by
the classical "()".

***** Empty
This should be fine:
#+begin_src lean4
inductive Empty where

#check Empty
#+end_src

"The Empty datatype has no constructors whatsoever. Thus, it indicates unreachable code, because no series of calls can ever terminate with a value at type Empty.

Empty is not used nearly as often as Unit. However, it is useful in some specialized contexts. Many polymorphic datatypes do not use all of their type arguments in all of their constructors. For instance, Sum.inl and Sum.inr each use only one of Sum's type arguments. Using Empty as one of the type arguments to Sum can rule out one of the constructors at a particular point in a program. This can allow generic code to be used in contexts that have additional restrictions."
*** Additional Conveniences
**** Automatic Implicit Arguments
"When writing polymorphic functions in Lean, it is typically not necessary to list all the implicit arguments."

So, that definition:
#+begin_src lean4
def length {Œ± : Type} (xs : List Œ±) : Nat :=
  match xs with
  | []      => 0
  | y :: ys => Nat.succ (length ys)
#+end_src

Can be written this way:
#+begin_src lean4
def length (xs : List Œ±) : Nat :=
  match xs with
  | []      => 0
  | y :: ys => Nat.succ (length ys)
#+end_src

**** Pattern-Matching Definitions
"When defining functions with def, it is quite common to name an argument and then immediately
use it with pattern matching. For instance, in length, the argument xs is used only in match.
In these situations, the cases of the match expression can be written directly, without naming the argument at all."

Example:
#+begin_src lean4
def length : List Œ± ‚Üí Nat
  | []      => 0
  | y :: ys => Nat.succ (length ys)
#+end_src

"This syntax can also be used to define functions that take more than one argument. In this case,
their patterns are separated by commas."

Example:
#+begin_src lean4
def drop : Nat ‚Üí List Œ± ‚Üí List Œ±
  | Nat.zero  , xs      => xs
  | _         , []      => []
  | Nat.succ n, x :: xs => drop n xs
#+end_src

"Named arguments and patterns can also be used in the same definition."
#+begin_src lean4
def fromOption (default : Œ±) : Option Œ± ‚Üí Œ±
  | none   => default
  | some x => x
#+end_src

"This function is called Option.getD in the standard library,
  and can be called with dot notation", btw.

#+begin_src lean4
#eval (some "salmonberry").getD "" --> "salmonberry"
#eval none.getD ""                 --> ""
#+end_src

**** Local Definitions
"In Lean, the result of the recursive call can be named, and thus saved, using let. Local definitions with let resemble top-level definitions with def: it takes a name to be locally defined, arguments if desired, a type signature, and then a body following :=. After the local definition, the expression in which the local definition is available (called the body of the let-expression) must be on a new line, starting at a column in the file that is less than or equal to that of the let keyword. For instance, let can be used in unzip like this:"
#+begin_src lean4
def unzip : List (Œ± √ó Œ≤) ‚Üí List Œ± √ó List Œ≤
  | []            => ([], [])
  | (x, y) :: xys =>
    let unzipped : List Œ± √ó List Œ≤ := unzip xys
    (x :: unzipped.fst, y :: unzipped.snd)
#+end_src

"To use let on a single line, separate the local definition from the body with a semicolon."

"Local definitions with let may also use pattern matching when one pattern is enough to match all cases of a datatype. In the case of unzip, the result of the recursive call is a pair. Because pairs have only a single constructor, the name unzipped can be replaced with a pair pattern:"
#+begin_src lean4
def unzip : List (Œ± √ó Œ≤) ‚Üí List Œ± √ó List Œ≤
  | [] => ([], [])
  | (x, y) :: xys =>
    let (xs, ys) : List Œ± √ó List Œ≤ := unzip xys
    (x :: xs, y :: ys)
#+end_src

NEW FEATURE:
"The biggest difference between let and def is that recursive let definitions must be explicitly indicated by writing let rec. For instance, one way to reverse a list involves a recursive helper function, as in this definition:"
#+begin_src lean4
def reverse (xs : List Œ±) : List Œ± :=
  let rec helper : List Œ± ‚Üí List Œ± ‚Üí List Œ±
    | [], soFar => soFar
    | y :: ys, soFar => helper ys (y :: soFar)
  helper xs []
#+end_src

**** Type Inference
"In many situations, Lean can automatically determine an expression's type. In these cases, explicit types may be omitted from both top-level definitions (with def) and local definitions (with let). For instance, the recursive call to unzip does not need an annotation:"
#+begin_src lean4
def unzip : List (Œ± √ó Œ≤) ‚Üí List Œ± √ó List Œ≤
  | []            => ([], [])
  | (x, y) :: xys =>
    let unzipped := unzip xys
    (x :: unzipped.fst, y :: unzipped.snd)
#+end_src

In deed, it could even be like this:
#+begin_src lean4
def unnzip : List (Œ± √ó Œ≤) ‚Üí List Œ± √ó List Œ≤
  | []            => ([], [])
  | (x, y) :: xys =>
    let (xs, ys) := unzip xys
    (x :: xs, y :: ys)
#+end_src

"Omitting the return type for unzip is possible when using an explicit match expression:"
#+begin_src lean4
def unzip (pairs : List (Œ± √ó Œ≤)) :=
  match pairs with
  | [] => ([], [])
  | (x, y) :: xys =>
    let unzipped := unzip xys
    (x :: unzipped.fst, y :: unzipped.snd)
#+end_src

"Missing type annotations can give confusing error messages. Omitting all types from the definition of unzip:"
#+begin_src lean4
def unzip pairs :=
  match pairs with
  | [] => ([], [])
  | (x, y) :: xys =>
    let unzipped := unzip xys
    (x :: unzipped.fst, y :: unzipped.snd)
#+end_src

It generate this error message:
#+begin_src error
invalid match-expression, pattern contains metavariables
  []
#+end_src

"This is because match needs to know the type of the value being inspected, but that type was not available."

"Even some very simple programs require type annotations. For instance, the identity function just returns whatever argument it is passed. With argument and type annotations, it looks like this:"
#+begin_src lean4
def id (x : Œ±) : Œ± := x
#+end_src

"Lean is capable of determining the return type on its own:"
#+begin_src lean4
def id (x : Œ±) := x
#+end_src

"Omitting the argument type, however, causes an error:"
#+begin_src lean4
def id x := x --> (!) failed to infer binder type
#+end_src

**** Simultaneous Matching
"Pattern-matching expressions, just like pattern-matching definitions, can match on multiple values at once. "

Look at this:
#+begin_src lean4
def drop (n : Nat) (xs : List Œ±) : List Œ± :=
  match n, xs with
  | Nat.zero   , ys      => ys
  | _          , []      => []
  | Nat.succ n , y :: ys => drop n ys
#+end_src

**** Natural Number Patterns
"Just as there is special syntax to make list patterns more readable
than using List.cons and List.nil directly, natural numbers can be
matched using literal numbers and +. For instance, even can also be
defined like this:"
#+begin_src lean4
def even : Nat ‚Üí Bool
  | 0     => true
  | n + 1 => not (even n)
#+end_src

The explicit patterns in halve, which divides a Nat by two and drops the remainder:
#+begin_src lean4
def halve : Nat ‚Üí Nat
  | Nat.zero => 0
  | Nat.succ Nat.zero => 0
  | Nat.succ (Nat.succ n) => halve n + 1
#+end_src

can be replaced by numeric literals and +:
#+begin_src lean4
def halve : Nat ‚Üí Nat
  | 0     => 0
  | 1     => 0
  | n + 2 => halve n + 1
#+end_src

"When using this syntax, the second argument to + should always be a literal Nat. Even though addition is commutative."

**** Anonymous Functions
The both can be used:
#+begin_src lean4
#check fun
  | 0 => none
  | n + 1 => some n
#check Œª
  | 0 => none
  | n + 1 => some n
#+end_src

So, basicaly: fun = Œª.
It's a bit more usual to use "fun" instead of "Œª", btw.

Awelsome syntax gift:
"When an anonymous function is very simple, like fun x => x + 1, the syntax for creating the function can be fairly verbose. In that particular example, six non-whitespace characters are used to introduce the function, and its body consists of only three non-whitespace characters. For these simple cases, Lean provides a shorthand. In an expression surrounded by parentheses, a centered dot character ¬∑ can stand for an argument, and the expression inside the parentheses becomes the function's body. That particular function can also be written (¬∑ + 1)."

"The centered dot always creates a function out of the closest surrounding set of parentheses. For instance, (¬∑ + 5, 3) is a function that returns a pair of numbers, while ((¬∑ + 5), 3) is a pair of a function and a number. If multiple dots are used, then they become arguments from left to right:"

#+begin_src lean4
(¬∑ , ¬∑) 1 2
===>
(1, ¬∑) 2
===>
(1, 2)
#+end_src

**** Namespaces
Each name in Lean occurs in a namespace, which is a collection of names. Names are placed in namespaces using ., so List.map is the name map in the List namespace.

Names can be directly defined within a namespace. For instance, the name double can be defined in the Nat namespace:
#+begin_src lean4
def Nat.double (x : Nat) : Nat := x + x
#+end_src

Because Nat is also the name of a type, dot notation is available to call Nat.double on expressions with type Nat:
#+begin_src lean4
#eval (4 : Nat).double
#+end_src

In addition to defining names directly in a namespace, a sequence of declarations can be placed in a namespace using the namespace and end commands. For instance, this defines triple and quadruple in the namespace NewNamespace:
#+begin_src lean4
namespace NewNamespace
def triple    (x : Nat) : Nat := 3 * x
def quadruple (x : Nat) : Nat := 2 * x + 2 * x
end NewNamespace
#+end_src

"Namespaces may be opened, which allows the names in them to be used without explicit qualification. Writing open MyNamespace in before an expression causes the contents of MyNamespace to be available in the expression. For example, timesTwelve uses both quadruple and triple after opening NewNamespace:"
#+begin_src lean4
def timesTwelve (x : Nat) :=
  open NewNamespace in
  quadruple (triple x)
#+end_src

Namespaces can also be opened prior to a command. This allows all parts of the command to refer to the contents of the namespace, rather than just a single expression. To do this, place the open ... in prior to the command.
#+begin_src lean4
open NewNamespace in
#check quadruple
#+end_src

Important:
"Function signatures show the name's full namespace. Namespaces may additionally be opened for all following commands for the rest of the file. To do this, simply omit the in from a top-level usage of open."

**** if let
a function that recognizes string elements and extracts their contents can be written:
#+begin_src lean4
def Inline.string? (inline : Inline) : Option String :=
  match inline with
  | Inline.string s => some s
  | _               => none
#+end_src

An alternative way of writing this function's body uses if together with let:
#+begin_src lean4
def Inline.string? (inline : Inline) : Option String :=
  if let Inline.string s := inline then
    some s
  else none
#+end_src

It really look like some `instanceOf`'s.. Ugly, yeah!

**** Positional Structure Arguments
With some context, like definitions, because
Structures are essencialy tupples, we can write
it like this:
#+begin_src lean4
#eval (‚ü®1, 2‚ü© : Point)
#+end_src
**** String Interpolation
"In Lean, prefixing a string with s! triggers interpolation, where expressions contained in curly braces inside the string are replaced with their values. This is similar to f-strings in Python and $-prefixed strings in C#. For instance,"
#+begin_src lean4
#eval s!"three fives is {NewNamespace.triple 5}"
 --> "three fives is 15"
#+end_src

*** TODO "Summary"
** Hello, World!
*** Compiling
So u use `lean --rn file-name.lean` in order
to compile things.

*** The main
The main should look similar to in Haskell as bellow:
#+begin_src lean4
def main : IO Unit := IO.println "Hello, world!"
#+end_src

*** The IO
In a first look, the usage looks pretty similar to Haskells.
#+begin_src lean4
def main : IO Unit := do
  let stdin  ‚Üê IO.getStdin
  let stdout ‚Üê IO.getStdout

  stdout.putStrLn "How would you like to be addressed?"
  let input ‚Üê stdin.getLine
  let name := input.dropRightWhile Char.isWhitespace

  stdout.putStrLn s!"Hello, {name}!"
#+end_src

*** Build Tool's (Lake)
**** Lake intro
The standard Lean build tool is called Lake (short for "Lean Make").

"Just as Lean contains a special-purpose language for writing programs with effects (the do language), Lake contains a special-purpose language for configuring builds."

**** Creating a project
Lake new create a new project in a new directory, to create a project in an already-existing directory,
run lake init instead.

**** Special "<< name >>"
Placing guillemets around a name, as in ¬´Greeting¬ª, allow it to contain spaces or other characters that are normally not allowed in Lean names, and it allows reserved keywords such as if or def to be used as ordinary names by writing ¬´if¬ª or ¬´def¬ª. This prevents issues when the package name provided to lake new contains such characters.

**** Running the project
To build the package, run the command lake build. After a number of build commands scroll by, the
resulting binary has been placed in build/bin. Running `./build/bin/greeting` results in Hello, world!.

To me it appeared in a file inside `.lake/build/bin/`

**** Lake documentation link
https://github.com/leanprover/lean4/blob/master/src/lake/README.md

**** Lean4 as the Lider
"Additionally, Lakefiles may contain external libraries, which are libraries not written in Lean to be
statically linked with the resulting executable."

**** Module vs Namespaces
"Import is used to make the contents of a source file available, while open makes names from a namespace available in the current context without prefixes."

**** Selective Openning
Similar to Haskell, (but with the segragation of module vs namespace), you can write
`open Nat (toFloat)` to get only open `toFloat` to usage.

**** Main Types
 In Lean, main can have one of three types:

- main : IO Unit corresponds to programs that cannot read their command-line arguments and always indicate success with an exit code of 0

- main : IO UInt32 corresponds to int main(void) in C, for programs without arguments that return exit codes, and

- main : List String ‚Üí IO UInt32 corresponds to int main(int argc, char **argv) in C, for programs that take arguments and signal success or failure.
*** TODO Conveniences
*** TODO Summary
** Overloading and Type Classes
*** Intro
**** Intro
A type class consists of a name, some parameters, and a collection of methods.

declaring a type class really results in the following:

A structure type to contain the implementation of each overloaded operation
A namespace with the same name as the class
For each method, a function in the class's namespace that retrieves its implementation from an instance

**** Parameters
Describe the types for which overloadable operations are being defined
**** Methods
Are the names and type signatures of the overloadable operations.
**** Short Example
#+begin_src lean4
class Plus (Œ± : Type) where
  plus : Œ± ‚Üí Œ± ‚Üí Œ±

instance : Plus Nat where
  plus := Nat.add
#+end_src
**** HAdd and HMul
HAdd is short for heterogeneous addition.
For example, an HAdd instance can be written to allow a Nat to be added to a Float, resulting in a new Float. When a programmer writes x + y, it is interpreted as meaning HAdd.hAdd x y.

#+begin_src lean4
def addNatPos : Nat ‚Üí Pos ‚Üí Pos
  | 0    , p => p
  | n + 1, p => Pos.succ (addNatPos n p)

def addPosNat : Pos ‚Üí Nat ‚Üí Pos
  | p, 0     => p
  | p, n + 1 => Pos.succ (addPosNat p n)
#+end_src

this type of of overloading is a lot more powerful than the "Add" and "Mul", because here we can add things with 2 diferent types. From this example, let's see it working:

#+begin_src lean4
instance : HAdd Nat Pos Pos where
  hAdd := addNatPos

instance : HAdd Pos Nat Pos where
  hAdd := addPosNat

#eval (3 : Pos) + (5 : Nat) --> 8
#eval (3 : Nat) + (5 : Pos) --> 8
#+end_src

**** Very very useful thing i've made
Since the Lean libraries are set up so that an instance of Add will be found when searching for an instance of HAdd in which both arguments have the same type, i did:
#+begin_src lean4
instance : Add Type where
  add := Sum
-- and now it's possible to write:
#check Int + String --> Type
#+end_src

Just as "HAdd", there's a "HMul" and also there's a simplier "Mul"
for the case when the two arguments have the same type.

**** Literals ("OfNat" class)
In Lean, natural number literals are interpreted using a type class called OfNat:
#+begin_src lean4
class OfNat (Œ± : Type) (_ : Nat) where
  ofNat : Œ±
#+end_src

**** Very weird thing!
#+begin_src lean4
class Foo (n : Nat) where
  const : Nat
open Foo

instance : Foo 5 where
  const := 42

instance : Foo 4 where
  const := 53

#eval const 5 --> 42
#eval const 4 --> 53
#eval const 3 --> !ERROR "failed to synthetize"
#end_src
**** TODO A Short Example (HTTP)
*** Polymorphism
**** About constraints
Here the "IO.println" need to receive a type that insatnciate the "ToString" class.

#+begin_src lean4
#check IO.println   --> IO.prinln.{u_1} {Œ± : Type u_1} [ToString Œ±] (s : Œ±) : IO Unit
#check (IO.println) --> IO.println : ?m.10872 ‚Üí IO Unit
#check @IO.println  --> @IO.println : {Œ± : Type u_1} ‚Üí [inst : ToString Œ±] ‚Üí Œ± ‚Üí IO Unit
#+end_src

In Lean4, they call constraints as "Instance Implicits"
**** Defining Polymorphic Functions with Instance Implicits
There is an example:
#+begin_src lean4
def List.sum [Add Œ±] [OfNat Œ± 0] : List Œ± ‚Üí Œ±
 | []      => 0
 | x :: xs => x + xs.sum

instance [Add Œ±] : Add (PPoint Œ±) where
  add p1 p2 := { x := p1.x + p2.x, y := p1.y + p2.y }
#+end_src

**** TODO Even Number Literals
Write an instance of OfNat for the even number datatype from the previous section's (4.1) exercises that uses recursive instance search.
For the base instance, it is necessary to write OfNat Even Nat.zero instead of OfNat Even 0.
*** WAIT Instance Search
**** Intro
In the past we've be seen the HAdd type class.

The definition of the HAdd type class is very much like the following definition of HPlus
#+begin_src lean4
class HPlus (Œ± : Type) (Œ≤ : Type) (Œ≥ : Type) where
  hPlus : Œ± ‚Üí Œ≤ ‚Üí Œ≥

-- but:
#eval HPlus.hPlus (3 : Pos) (5 : Nat)         --> !Error
#eval (HPlus.hPlus (3 : Pos) (5 : Nat) : Pos) --> 8
#+end_src

**** Default Instances
"Default instances are instances that are available for instance search even when not all their inputs are known."

One example of where default instances can be useful is an instance of HPlus that can be derived from an Add instance. In other words, ordinary addition is a special case of heterogeneous addition in which all three types happen to be the same. This can be implemented using the following instance:
#+begin_src lean4
instance [Add Œ±] : HPlus Œ± Œ± Œ± where
  hPlus := Add.add

-- But:
#check HPlus.hPlus (5 : Nat) --> HPlus.hPlus 5 : ?m.7706 ‚Üí ?m.7708
#+end_src

In the vast majority of cases, when someone supplies one argument to addition, the other argument will have the same type. To make this instance into a default instance, apply the default_instance attribute:
#+begin_src lean4
@[default_instance]
instance [Add Œ±] : HPlus Œ± Œ± Œ± where
  hPlus := Add.add

-- And now:
#check HPlus.hPlus (5 : Nat) --> HPlus.hPlus 5 : Nat ‚Üí Nat
#+end_src

For more details, consult the Lean4 manual!

*** Arrays
**** Intro
For instance, Lean arrays are much more efficient than linked lists for most purposes. In Lean, the type Array Œ± is a dynamically-sized array holding values of type Œ±, much like a Java ArrayList, a C++ std::vector

**** FunFact about compiler
In pure functional languages like Lean, it is not possible to mutate a given position in a data structure. Instead, a copy is made that has the desired modifications. When using an array, the Lean compiler and runtime contain an optimization that can allow modifications to be implemented as mutations behind the scenes when there is only a single unique reference to an array.

**** Example
Arrays are written similarly to lists, but with a leading #:
#+begin_src lean4
def northernTrees : Array String :=
  #["sloe", "birch", "elm", "oak"]

#eval northernTrees.size --> 4
#+end_src

*** Non-Empty Lists
Default implementation:
#+begin_src lean4
structure NonEmptyList (Œ± : Type) : Type where
  head : Œ±
  tail : List Œ±
#+end_src

Example of functions beein declared about this type:
#+begin_src lean4
def NonEmptyList.get? : NonEmptyList Œ± ‚Üí Nat ‚Üí Option Œ±
  | xs, 0 => some xs.head
  | {head := _, tail := []}, _ + 1 => none
  | {head := _, tail := h :: t}, n + 1 => get? {head := h, tail := t} n

-- Another idea:
def NonEmptyList.get? : NonEmptyList Œ± ‚Üí Nat ‚Üí Option Œ±
  | xs, 0 => some xs.head
  | xs, n + 1 => xs.tail.get? n
#+end_src

*** Overloading Indexing
**** Intro
Indexing notation for a collection type can be overloaded by defining an instance of the GetElem type class.
Here are the paramters:
- The type of the collection,
- The type of the index,
- The type of elements that are extracted from the collection,
- A function that determines what counts as evidence that the index is in bounds;

Here's the implementation:
#+begin_src lean4
class GetElem (coll : Type) (idx : Type) (item : outParam Type) (inBounds : outParam (coll ‚Üí idx ‚Üí Prop)) where
  getElem : (c : coll) ‚Üí (i : idx) ‚Üí inBounds c i ‚Üí item
#+end_src

Here's some instancement's
#+begin_src lean4
instance : GetElem (NonEmptyList Œ±) Nat Œ± NonEmptyList.inBounds where
  getElem :=
    fun : (xs : NonEmptyList Œ±) (i : Nat) (ok : xs.inBounds i) : Œ± :=
      match i with
      | 0     => xs.head
      | n + 1 => xs.tail[n]

instance : GetElem (PPoint Œ±) Bool Œ± (fun _ _ => True) where
getElem (p : PPoint Œ±) (i : Bool) _ :=
  if not i then p.x else p.y
#+end_src

*** Standard Classes
**** Intro
Firstly i want to say that this text is just so good that i'll just C-w and C-y it here :).

This section presents a variety of operators and functions that can be overloaded using type classes in Lean. Each operator or function corresponds to a method of a type class. Unlike C++, infix operators in Lean are defined as abbreviations for named functions; this means that overloading them for new types is not done using the operator itself, but rather using the underlying name (such as HAdd.hAdd).

**** Arithmetic
Most arithmetic operators are available in a heterogeneous form, where the arguments may have different type and an output parameter decides the type of the resulting expression. For each heterogeneous operator, there is a corresponding homogeneous version that can found by removing the letter h, so that HAdd.hAdd becomes Add.add. The following arithmetic operators are overloaded:

[[file:./contents/images/Screenshot From 2025-03-12 19-28-45.png]]

**** Bitwise Operators
Lean contains a number of standard bitwise operators that are overloaded using type classes. There are instances for fixed-width types such as UInt8, UInt16, UInt32, UInt64, and USize. The latter is the size of words on the current platform, typically 32 or 64 bits. The following bitwise operators are overloaded:

[[file:./contents/images/Screenshot From 2025-03-12 19-34-44.png]]

Because the names And and Or are already taken as the names of logical connectives, the homogeneous versions of HAnd and HOr are called AndOp and OrOp rather than And and Or.

**** Equality and Ordering
It's just simple:
#+begin_src lean4
#check (¬∑ = ¬∑)  --> fun x1 x2 => x1 = x2  : ?m.4509 ‚Üí ?m.4509 ‚Üí Prop
#check (¬∑ == ¬∑) --> fun x1 x2 => x1 == x2 : ?m.4523 ‚Üí ?m.4523 ‚Üí Bool
#+end_src

Some values, such as functions, cannot be checked for equality, btw.
Also, some propositions are decidable, what makes possible to use then into
a if statement, like that:
#+begin_src lean4
#check 2 < 3                 --> 2 < 3 : Prop
#eval if 2 < 3 then 1 else 2 --> 1
#+end_src

The following propositions, that are usually decidable, are overloaded with type classes:

[[file:./contents/images/Screenshot From 2025-03-13 09-59-33.png]]

About ordering, just like in Coq, Lean4 has a "Ordering":
#+begin_src lean4
inductive Ordering where
| lt
| eq
| gt
#+end_src

A good example that i've made by myself:
#+begin_src lean4
def Nat.comp : Nat ‚Üí Nat ‚Üí Ordering
  | 0, 0         => Ordering.eq
  | _, 0         => Ordering.gt
  | 0, _         => Ordering.lt
  | n + 1, m + 1 => Nat.comp n m
#+end_src

**** Hashing
Here's the Lean4 implemented especification:
#+begin_src lean4
class Hashable (Œ± : Type) where
  hash : Œ± ‚Üí UInt64
#+end_src

I think that some laws could be added
#+begin_src lean4
class MyHashable (Œ± : Type) where
  hash : Œ± ‚Üí UInt64
  eqPreserv : ‚àÄ(a‚ÇÅ a‚ÇÇ : Œ±), a‚ÇÅ = a‚ÇÇ ‚Üí
                hash a‚ÇÅ = hash a‚ÇÇ
#+end_src
Or even maybe a boolanized version of this.

"The standard library contains a function mixHash with type UInt64 ‚Üí UInt64 ‚Üí UInt64 that can be used to combine hashes for different fields for a constructor."

With this, we can write:
#+begin_src lean4
def hashNat : Nat ‚Üí UInt64
  | 0     => 0
  | n + 1 => mixHash 1 (hashNat n)

instance : Hashable Nat where
  hash := hashNat
#+end_src

**** Constraints
Just look at this:
#+begin_src lean4
inductive BinTree (Œ± : Type) where
  | leaf : BinTree Œ±
  | branch : BinTree Œ± ‚Üí Œ± ‚Üí BinTree Œ± ‚Üí BinTree Œ±

def eqBinTree [BEq Œ±] : BinTree Œ± ‚Üí BinTree Œ± ‚Üí Bool
  | BinTree.leaf, BinTree.leaf =>
    true
  | BinTree.branch l x r, BinTree.branch l2 x2 r2 =>
    x == x2 && eqBinTree l l2 && eqBinTree r r2
  | _, _ =>
    false

instance [BEq Œ±] : BEq (BinTree Œ±) where
  beq := eqBinTree

def hashBinTree [Hashable Œ±] : BinTree Œ± ‚Üí UInt64
  | BinTree.leaf =>
    0
  | BinTree.branch left x right =>
    mixHash 1 (mixHash (hashBinTree left) (mixHash (hash x) (hashBinTree right)))

instance [Hashable Œ±] : Hashable (BinTree Œ±) where
  hash := hashBinTree
#+end_src

**** Deriving
"Instances can be derived in two ways. The first can be used when defining a structure or inductive type. In this case, add deriving to the end of the type declaration followed by the names of the classes for which instances should be derived. For a type that is already defined, a standalone deriving command can be used. Write deriving instance C1, C2, ... for T to derive instances of C1, C2, ... for the type T after the fact."

Example:
#+begin_src lean4
deriving instance BEq, Hashable for Pos
deriving instance BEq, Hashable, Repr for NonEmptyList
#+end_src

Instances can be derived for at least the following classes:
- Inhabited
- BEq
- Repr
- Hashable
- Ord

  (There's no code generator was found for ToString, btw..)

**** Appending
"Instances can be derived in two ways. The first can be used when defining a structure or inductive type. In this case, add deriving to the end of the type declaration followed by the names of the classes for which instances should be derived. For a type that is already defined, a standalone deriving command can be used. Write deriving instance C1, C2, ... for T to derive instances of C1, C2, ... for the type T after the fact."

Example:
#+begin_src lean4
deriving instance BEq, Hashable for Pos
deriving instance BEq, Hashable, Repr for NonEmptyList
#+end_src

Instances can be derived for at least the following classes:
- Inhabited
- BEq
- Repr
- Hashable
- Ord

There's the type class:
#+begin_src lean4
class HAppend (Œ± : Type) (Œ≤ : Type) (Œ≥ : outParam Type) where
  hAppend : Œ± ‚Üí Œ≤ ‚Üí Œ≥
#+end_src

There's a heterogeneous implementation above it:
#+begin_src lean4
instance : HAppend (NonEmptyList Œ±) (List Œ±) (NonEmptyList Œ±) where
  hAppend xs ys :=
    { head := xs.head, tail := xs.tail ++ ys }
#+end_src


**** Functors
Like Haskell, we have the "<$>" operator, so u can do:
#+begin_src lean4
#eval (¬∑ + 5) <$> [1, 2, 3] --> [6, 7, 8]
#+end_src

A instance for PPoint:
#+begin_src lean4
instance : Functor PPoint where
  map f p := { x := f p.x, y := f p.y }
#+end_src

Just a default implementation used in a primite way to think in Functors:
#+begin_src lean4
class Functor (f : Type ‚Üí Type) where
  map : {Œ± Œ≤ : Type} ‚Üí (Œ± ‚Üí Œ≤) ‚Üí f Œ± ‚Üí f Œ≤

  mapConst {Œ± Œ≤ : Type} (x : Œ±) (coll : f Œ≤) : f Œ± :=
    map (fun _ => x) coll
#+end_src

A maturier idea:
#+begin_src lean4
class Funktor (F : Type ‚Üí Type) where
  -- Operations:
  map : {Œ± Œ≤ : Type} ‚Üí (Œ± ‚Üí Œ≤) ‚Üí F Œ± ‚Üí F Œ≤

  mapConst {Œ± Œ≤ : Type} (x : Œ±) (coll : F Œ≤) : F Œ± :=
    map (fun _ => x) coll

 -- Laws:
  id_law   : ‚àÄ(f_a : F Œ±), map id f_a = fa
  comp_law : ‚àÄ(f : Œ± ‚Üí Œ≤), ‚àÄ(g : Œ≤ ‚Üí Œ≥), ‚àÄ(f_a : F Œ±),
               map (g ‚àò f) f_a = map g (map f f_a)

  -- Being associative was a theorem then?
#+end_src

Some implementation:
#+begin_src lean4
instance : Funktor BinTree where
  map := binTreeMap
#+end_src

*** TODO Coercions
**** Intro
"In Lean, both purposes are served by a mechanism called coercions. When Lean encounters an expression of one type in a context that expects a different type, it will attempt to coerce the expression before reporting a type error. Unlike Java, C, and Kotlin, the coercions are extensible by defining instances of type classes."

**** The Coe typeclass
The type class Coe describes overloaded ways of coercing from one type to another:
#+begin_src lean4
class coe (Œ± : type) (Œ≤ : type) where
  coe : Œ± ‚Üí Œ≤
#+end_src

An instance of Coe Pos Nat is enough to allow the prior code to work:
#+begin_src lean4
instance : Coe Pos Nat where
  coe x := x.toNat

#eval  [1, 2, 3, 4].drop (2 : Pos) --> [3, 4]
#check [1, 2, 3, 4].drop (2 : Pos) --> List.drop (Pos.toNat 2) [1, 2, 3, 4] : List Nat
#+end_src

**** Coe Chains
When searching for coercions, Lean will attempt to assemble a coercion out of a chain of smaller coercions. For example, there is already a coercion from Nat to Int. Because of that instance, combined with the Coe Pos Nat instance, the following code is accepted:
#+begin_src lean4
def oneInt : Int := Pos.one
#+end_src

This definition uses two coercions: from Pos to Nat, and then from Nat to Int.

Btw, they don't get circular and also it has a standart coercion about "Option" so all of this compiles:
#+begin_src lean4
#check ("oi" : Option String)
#check Option Type
def perhapsPerhapsPerhaps : Option (Option (Option String)) :=
  "Please don't tell me"
def perhapsPerhapsPerhapsNat : Option (Option (Option Nat)) :=
  ‚Üë(392 : Nat)
#+end_src

That arrow, btw, is used to ensure that Lean finds the right
instances. It can also make the programmer's intentions more clear.

**** Dependent Coercions (The CoeDep typeclass)
There's the class:
#+begin_src lean4
class CoeDep (Œ± : Type) (x : Œ±) (Œ≤ : Type) where
  coe : Œ≤
#+end_src

There's a use:
#+begin_src lean4
instance : CoeDep (List Œ±) (x :: xs) (NonEmptyList Œ±) where
  coe := { head := x, tail := xs }
#+end_src

***** Some more explanation
"Dependent coercions can be used when the ability to coerce from one type to another depends on which particular value is being coerced. Just as the OfNat type class takes the particular Nat being overloaded as a parameter, dependent coercion takes the value being coerced as a parameter"

"This is a chance to select only certain values, either by imposing further type class constraints on the value or by writing certain constructors directly."

**** TODO Coercing to Types (The CoeSort typeclass)
 Just as Coe is checked when a type mismatch occurs, CoeSort is used when something other than a sort is provided in a context where a sort would be expected.

 Some examples of sort (Type or Prop)
 #+begin_src lean4
instance : CoeSort Monoid Type where
  coe m := m.Carrier
 #+end_src

Another example:
#+begin_src lean4
instance : CoeSort Bool Prop where
  coe b := b = true

#check (if ¬∑ then ¬∑ else ¬∑) --> !Error [...] &
       -- (fun x1 x2 x3 => ?m.9836 : Prop ‚Üí ?m.9869 ‚Üí ?m.9869 ‚Üí ?m.9869)
#+end_src

Rather than have two kinds of if expression, the Lean standard library defines a coercion from Bool to
the proposition that the Bool in question is equal to true.

**** TODO Coercing to Funcions
That's is weird..
Here's the implementation:
#+begin_src lean4
class CoeFun (Œ± : Type) (makeFunctionType : outParam (Œ± ‚Üí Type)) where
  coe : (x : Œ±) ‚Üí makeFunctionType x
#+end_src

And here's the weird example:
#+begin_src lean4
structure Adder where
  howMuch : Nat

def add5 : Adder := ‚ü®5‚ü©
instance : CoeFun Adder (fun _ => Nat ‚Üí Nat) where
  coe a := (¬∑ + a.howMuch)

#eval add5 3 --> 8
#+end_src

**** TODO The "With great power comes great responsibility" talk
a

*** TODO Additional Conveniences
*** TODO My Own Summary
** TODO Monads
*** Intro
This whole chapter just uses so many different examples of monads that isnt helping me at all :P.
I think that im finishing this book first and investigating the monads later.

*** TODO Here the monad's that i'll want to investigate as functors and applicatives before monads:
- Id
- Except
- State
- Logging/WithLog

*** Typeclass
There's the implementation
#+begin_src lean4
class Monad (m : Type ‚Üí Type) where
  pure : Œ± ‚Üí m Œ±
  bind : m Œ± ‚Üí (Œ± ‚Üí m Œ≤) ‚Üí m Œ≤
#+end_src

** TODO Functors, Applicative Functors, and Monads
** TODO Monad Transformers
** TODO Programming with Dependent Types

** TODO What exacly is an output parameter???
* Theorem Proving in Lean 4
** Intro
"The Lean Theorem Prover aims to bridge the gap between interactive and automated theorem proving, by situating automated tools and methods in a framework that supports user interaction and the construction of fully specified axiomatic proofs. The goal is to support both mathematical reasoning and reasoning about complex systems, and to verify claims in both domains."

I'm basically following the book.
** Dependent type theory in Lean4
*** Intro
"Dependent type theory is a powerful and expressive language, allowing you to express complex mathematical assertions, write complex hardware and software specifications, and reason about both of these in a natural and uniform way. Lean is based on a version of dependent type theory known as the Calculus of Constructions, with a countable hierarchy of non-cumulative universes and inductive types. By the end of this chapter, you will understand much of what this means.

*** Simple Type Theory
**** Intro
Basically Types are firt class citisens and so u can do things
like above and even more.
#+begin_src lean4
def Œ± : Type := Nat
def Œ≤ : Type := Bool
def F : Type ‚Üí Type := List
def G : Type ‚Üí Type ‚Üí Type := Prod
#+end_src

Here's one of the most subtle aspects of Lean's typing system. Lean's underlying foundation has an infinite hierarchy of types:
#+begin_src lean4
#check Type     -- Type 1
#check Type 1   -- Type 2
#check Type 2   -- Type 3
#check Type 3   -- Type 4
#check Type 4   -- Type 5
#+end_src

`Type` is an abbreviation to `Type 0`, btw.
In order to define a polymorphic (over type universes)
constant, u have basically two ways:
#+begin_src lean4
-- first
universe u
def F (Œ± : Type u) : Type u := Prod Œ± Œ±
#check F    -- Type u ‚Üí Type u

-- secound
def F.{u} (Œ± : Type u) : Type u := Prod Œ± Œ±
#check F    -- Type u ‚Üí Type u
#+end_src

Using `universe u in` or simple dosnt use anything there just
works.. Don't blame me, blame the Lean4 bible.

**** Alpha Equivalence
"Formally, expressions that are the same up to a renaming of bound variables are called alpha equivalent, and are considered "the same." Lean recognizes this equivalence."

examples:
#+begin_src lean4
#check fun f x => f x
#check fun t s => t s
#+end_src

So, basically, they're the same.

**** A Small talk about let vs fun
So, the `let` expressions looks very similar to the lambda abstractions, but,
to set up a lambda abstraction, the thing should make sense without arguments
aplied yet. In the other hand, the `let` keyword has only a sintax meaning, it
is: an abbreviation to a term in a expression. Here's the good example used in
the book:
#+begin_src lean4
def foo := let a := Nat; fun x : a => x + 2  --> works
def bar := (fun a => fun x : a => x + 2) Nat --> bugs because the `+` is'nt for everytype.
#+end_src

**** Variables and Sections
While using this make the code looks clear and clean,
it doesn't look required in these days:
#+begin_src lean4
variable (Œ± Œ≤ Œ≥ : Type)

def compose (g : Œ≤ ‚Üí Œ≥) (f : Œ± ‚Üí Œ≤) (x : Œ±) : Œ≥ :=
  g (f x)

def doTwice (h : Œ± ‚Üí Œ±) (x : Œ±) : Œ± :=
  h (h x)

def doThrice (h : Œ± ‚Üí Œ±) (x : Œ±) : Œ± :=
  h (h (h x))
#+end_src

U can do it with more complex variables like here:
#+begin_src lean4
variable (Œ± Œ≤ Œ≥ : Type)
variable (g : Œ≤ ‚Üí Œ≥) (f : Œ± ‚Üí Œ≤) (h : Œ± ‚Üí Œ±)
variable (x : Œ±)

def compose := g (f x)
def doTwice := h (h x)
def doThrice := h (h (h x))

#print compose
#print doTwice
#print doThrice
#+end_src
, or even:
#+begin_src lean4
variable (x y : Nat)
variable (n : true)

-- [...]
#+end_src

When declared in this way, a variable stays in scope until the end of the file you are working on. Sometimes, however, it is useful to limit the scope of a variable. For that purpose, Lean provides the notion of a section:
#+begin_src lean4
section useful
  variable (Œ± Œ≤ Œ≥ : Type)
  variable (g : Œ≤ ‚Üí Œ≥) (f : Œ± ‚Üí Œ≤) (h : Œ± ‚Üí Œ±)
  variable (x : Œ±)

  def compose := g (f x)
  def doTwice := h (h x)
  def doThrice := h (h (h x))
end useful
#+end_src

"When the section is closed, the variables go out of scope, and cannot be referenced any more.

You do not have to indent the lines within a section. Nor do you have to name a section, which is to say, you can use an anonymous section / end pair. If you do name a section, however, you have to close it using the same name. Sections can also be nested, which allows you to declare new variables incrementally."

**** Namespaces
It's easy and intuitive.
#+begin_src lean4
namespace Foo
  def a : Nat := 5
  def f (x : Nat) : Nat := x + 7

  def fa : Nat := f a

  namespace Bar
    def ffa : Nat := f (f a)

    #check fa
    #check ffa
  end Bar

  #check fa
  #check Bar.ffa
end Foo

#check Foo.fa
#check Foo.Bar.ffa

open Foo

#check fa
#check Bar.ffa
#+end_src

Btw, Namespaces that have been closed can later be reopened, even in another file:
#+begin_src lean4
namespace Foo
  def a : Nat := 5
  def f (x : Nat) : Nat := x + 7

  def fa : Nat := f a
end Foo

#check Foo.a
#check Foo.f

namespace Foo
  def ffa : Nat := f (f a)
end Foo
#+end_src

Like sections, nested namespaces have to be closed in the order they are opened. Namespaces and sections serve different purposes: namespaces organize data and sections declare variables for insertion in definitions. Sections are also useful for delimiting the scope of commands such as set_option and open.

In many respects, however, a namespace ... end block behaves the same as a section ... end block. In particular, if you use the variable command within a namespace, its scope is limited to the namespace. Similarly, if you use an open command within a namespace, its effects disappear when the namespace is closed.

**** What type dependent means?
A long example:
Given Œ± : Type and Œ≤ : Œ± ‚Üí Type, think of Œ≤ as a family of types over Œ±, that is, a type Œ≤ a for each a : Œ±. In that case, the type (a : Œ±) ‚Üí Œ≤ a denotes the type of functions f with the property that, for each a : Œ±, f a is an element of Œ≤ a. In other words, the type of the value returned by f depends on its input.

Notice that (a : Œ±) ‚Üí Œ≤ makes sense for any expression Œ≤ : Type. When the value of Œ≤ depends on a (as does, for example, the expression Œ≤ a in the previous paragraph), (a : Œ±) ‚Üí Œ≤ denotes a dependent function type. When Œ≤ doesn't depend on a, (a : Œ±) ‚Üí Œ≤ is no different from the type Œ± ‚Üí Œ≤. Indeed, in dependent type theory (and in Lean), Œ± ‚Üí Œ≤ is just notation for (a : Œ±) ‚Üí Œ≤ when Œ≤ does not depend on a.

Just as dependent function types (a : Œ±) ‚Üí Œ≤ a generalize the notion of a function type Œ± ‚Üí Œ≤ by allowing Œ≤ to depend on Œ±, dependent Cartesian product types (a : Œ±) √ó Œ≤ a generalize the Cartesian product Œ± √ó Œ≤ in the same way. Dependent products are also called sigma types, and you can also write them as Œ£ a : Œ±, Œ≤ a. You can use ‚ü®a, b‚ü© or Sigma.mk a b to create a dependent pair. The ‚ü® and ‚ü© characters may be typed with \langle and \rangle or \< and \>, respectively.

If i'm not crazy here, we're talking about things like The "List" it self.

But everything there is pretty weird and then, hey showed us this example:
#+begin_src lean4
universe u v

def f (Œ± : Type u) (Œ≤ : Œ± ‚Üí Type v) (a : Œ±) (b : Œ≤ a) : (a : Œ±) √ó Œ≤ a :=
  ‚ü®a, b‚ü©

def g (Œ± : Type u) (Œ≤ : Œ± ‚Üí Type v) (a : Œ±) (b : Œ≤ a) : Œ£ a : Œ±, Œ≤ a :=
  Sigma.mk a b

def h1 (x : Nat) : Nat :=
  (f Type (fun Œ± => Œ±) Nat x).2

#eval h1 5 -- 5

def h2 (x : Nat) : Nat :=
  (g Type (fun Œ± => Œ±) Nat x).2

#eval h2 5 -- 5
-- The functions f and g above denote the same function, btw
#+end_src

I've missed a more ilustrative example to show me why i would like that..
So i'll try to create something useless just to show something kinda useless
just to show something more than just "see? this generalize the thing that we already
had". Ok, but what's new then?
#+begin_src lean4
def h0 (n : Nat) : List Nat :=
  (f Type List Nat [n]).2

def h02 (n : Nat) : Type :=
  (f Type List Nat [n]).1

#check h0
#check h0 3
#eval  h0 3

def explain_that (Œ± : Type u) (Œ≤ : Œ± ‚Üí Type v) (a : Œ±) := Œ≤ a

#check explain_that Type List Nat
#check List
#+end_src

**** Implicit Arguments
Look at this:
#+begin_src lean4
#check Lst.cons Nat 0 (Lst.nil Nat)

def as : Lst Nat := Lst.nil Nat
def bs : Lst Nat := Lst.cons Nat 5 (Lst.nil Nat)

#check Lst.append Nat as bs
#+end_src

First of all, it make sense and it's very orthogonal but is also very ugly and verbous and
could/should be inferred by the type system. So we can do this in these way:
#+begin_src lean4
#check Lst.cons _ 0 (Lst.nil _)

def as : Lst Nat := Lst.nil _
def bs : Lst Nat := Lst.cons _ 5 (Lst.nil _)

#check Lst.append _ as bs
#+end_src

It is still tedious, however, to type all these underscores. When a function takes an argument that can generally be inferred from context, Lean allows you to specify that this argument should, by default, be left implicit. This is done by putting the arguments in curly braces, as follows:
#+begin_src lean4
universe u
def Lst (Œ± : Type u) : Type u := List Œ±

def Lst.cons {Œ± : Type u} (a : Œ±) (as : Lst Œ±) : Lst Œ± := List.cons a as
def Lst.nil {Œ± : Type u} : Lst Œ± := List.nil
def Lst.append {Œ± : Type u} (as bs : Lst Œ±) : Lst Œ± := List.append as bs

#check Lst.cons 0 Lst.nil

def as : Lst Nat := Lst.nil
def bs : Lst Nat := Lst.cons 5 Lst.nil

#check Lst.append as bs
#+end_src

Variables can also be specified as implicit when they are declared with the variable command:
#+begin_src lean4
universe u

section
  variable {Œ± : Type u}
  variable (x : Œ±)
  def ident := x
end

#check ident
#check ident 4
#check ident "hello"
#+end_src

The presence of implicit arguments means that at times there may be insufficient information to fix the meaning of an expression precisely. An expression like id or List.nil is said to be polymorphic, because it can take on different meanings in different contexts.

So it happens and that's how we'll solve it:
#+begin_src lean4
#check List.nil               -- List ?m
#check id                     -- ?m ‚Üí ?m

#check (List.nil : List Nat)  -- List Nat
#check (id : Nat ‚Üí Nat)       -- Nat ‚Üí Nat
#+end_src

Sometimes, however, we may find ourselves in a situation where we have declared an argument to a function to be implicit, but now want to provide the argument explicitly. If foo is such a function, the notation @foo denotes the same function with all the arguments made explicit.

See my own example:
#+begin_src lean4
#check id 3      --> Nat
#check @id Nat 3 --> Nat
#check @id Int 3 --> Int
#+end_src

** Propositions and Proofs
*** The implies example
In summary, we don't need to build a Proof above Props because
Props are types. So, in order to prove `p -> q`. So, if u
have a `t : p`, with a `f : p -> q` function u will have e "evidence of `q`"
which is `f t : q`.

*** TODO Every proof is the same?
"There are a few pragmatic differences between definitions and theorems, however. In normal circumstances, it is never necessary to unfold the "definition" of a theorem; by proof irrelevance, any two proofs of that theorem are definitionally equal. Once the proof of a theorem is complete, typically we only need to know that the proof exists;"

I really wanna know now how it could be. In this point i really want this book to answer this and if it doesnt i will have to back here some day..

*** The `show`
Basically has a command called "show" that provides
type anotations inside of theorems.
#+begin_src lean4
variable {p q : Prop}

theorem t1 : p ‚Üí q ‚Üí p :=
  fun hp : p =>
  fun hq : q =>
  show p from hp
#+end_src

I'm, personally,
i'm reading that "`show p from hp`" as the old exact command
because u're kinda 'showing' p and thats from hp indeed..

But Lean seens to look at it as type anotation from hp which is p...
What sounds to make sense with my another point because hp is nothing
different than a evidence of p with p beeing a assertion beeing showed
through hp.

"Adding such extra information can improve the clarity of a proof and help detect errors when writing a proof. The show command does nothing more than annotate the type, and, internally, all the presentations of t1 that we have seen produce the same term."

*** Option (Something about dependent theory)
"Remember that this type can just as well be written ‚àÄ (p q : Prop) (hp : p) (hq : q), p, since the arrow denotes nothing more than an arrow type in which the target does not depend on the bound variable."

It talks very much with something previosly explored but it's very very good to notice that..


*** Operators
**** Intro
Nothing's new, but maybe this table can be useful.
[[file:./contents/images/connectives_table.png]]

**** Conjunction
In summary:
#+begin_src lean4
#check And.intro -- {a b : Prop} (left : a) (right : b) : a ‚àß b
#check And.left  -- {a b : Prop} (self : a ‚àß b) : a
#check And.right -- {a b : Prop} (self : a ‚àß b) : b
#+end_src

**** Disjunction
In Summary:
#+begin_src lean4
#check Or.intro_left  -- {a : Prop} (b : Prop) (h : a) : a ‚à® b
#check Or.intro_right -- {b : Prop} (a : Prop) (h : b) : a ‚à® b
#check Or.elim        -- {a b c : Prop} (h : a ‚à® b) (left : a ‚Üí c) (right : b ‚Üí c) : c
#+end_src

We also have this shorthand:
#+begin_src lean4
#check Or.inl         -- {a b : Prop} (h : a) : a ‚à® b
#check Or.inr         -- {a b : Prop} (h : a) : a ‚à® b
#+end_src

**** Negation and Falsity
In Summary:
#+begin_src lean4
#check False.elim -- False.elim.{u} {C : sort u} (h : False) : C
#check absurd     -- absurd.{v} {a : Prop} {b : Sort v} (h‚ÇÅ : a) (h‚ÇÇ : ¬¨a) : b
#+end_src

**** True
In Summary
"Incidentally, just as False has only an elimination rule, True has only an introduction rule, True.intro : true. In other words, True is simply true, and has a canonical proof, True.intro."

**** Logical Equivalence
In summary:
#+begin_src lean4
#check Iff.intro -- {a b : Prop} (mp : a ‚Üí b) (mpr : b ‚Üí a) : a ‚Üî b
#check Iff.mp    -- {a b : Prop} (self : a ‚Üî b) : a ‚Üí b
#check Iff.mpr   -- {a b : Prop} (self : a ‚Üî b) : b ‚Üí a
#+end_src

things like this are also possible:
#+begin_src lean4
def thing : p ‚Üî p := ‚ü®id , id‚ü©

theorem and_swap : p ‚àß q ‚Üî q ‚àß p :=
  let f {r s : Prop} (h : r ‚àß s) : s ‚àß r := ‚ü®h.2, h.1‚ü©
  ‚ü®f, f‚ü©
#+end_src

**** Introducing Auxiliary Subgoals
This will serve as example:
#+begin_src lean4
namespace subgoals
variable (p q : Prop)

example (h : p ‚àß q) : q ‚àß p :=
  have hp : p := h.left
  have hq : q := h.right
  show q ‚àß p from ‚ü®hq, hp‚ü©

example (h : p ‚àß q) : q ‚àß p :=
  let hp : p := h.left
  let hq : q := h.right
  show q ‚àß p from ‚ü®hq, hp‚ü©

variable (p q : Prop)

example (h : p ‚àß q) : q ‚àß p :=
  have hp : p := h.left
  suffices hq : q from And.intro hq hp
  show q from And.right h

end subgoals
#+end_src

**** Classical Logic
So we can `open Classical` and use the dirty math
like em (excluded middle)
#+begin_src lean4
open Classical

variable (p : Prop)
#check em      -- Classical.em (p : Prop) : p ‚à® ¬¨p
#check byCases -- {p q : Prop} (hpq : p ‚Üí q) (¬¨p ‚Üí q) : q
#check byContradiction -- {p : Prop} (h : ¬¨p ‚Üí False) : p
#+end_src

** Quantifiers and Equality
*** The Universal Quantifier
It's just a sugar to dependent arrow types:
"Given a term t of type Œ≤ x, in a context where x : Œ± is arbitrary,
we have (fun x : Œ± => t) : (x : Œ±) ‚Üí Œ≤ x."

It was the introduction, the elimination states to:
"Given a term s : (x : Œ±) ‚Üí Œ≤ x and any term t : Œ±, we have s t : Œ≤ t."

Simply:
"In the case where p x has type Prop, if we replace (x : Œ±) ‚Üí Œ≤ x with ‚àÄ x : Œ±, p x, we can read these as the correct rules for building proofs involving the universal quantifier.

The Calculus of Constructions therefore identifies dependent arrow types with forall-expressions in this way. If p is any expression, ‚àÄ x : Œ±, p is nothing more than alternative notation for (x : Œ±) ‚Üí p, with the idea that the former is more natural than the latter in cases where p is a proposition. Typically, the expression p will depend on x : Œ±. Recall that, in the case of ordinary function spaces, we could interpret Œ± ‚Üí Œ≤ as the special case of (x : Œ±) ‚Üí Œ≤ in which Œ≤ does not depend on x. Similarly, we can think of an implication p ‚Üí q between propositions as the special case of ‚àÄ x : p, q in which the expression q does not depend on x."
*** Equality
In summary
#+begin_src lean4
#check Eq.refl    -- Eq.refl.{u_1} {Œ± : Sort u_1} (a : Œ±) : a = a
#check Eq.symm    -- Eq.symm.{u} {Œ± : Sort u} {a b : Œ±} (h : a = b) : b = a
#check Eq.trans   -- Eq.trans.{u} {Œ± : Sort u} {a b c : Œ±} (h‚ÇÅ : a = b) (h‚ÇÇ : b = c) : a = c
#+end_src

*** Calculational Proofs
In summary:
#+begin_src lean4
example (x y : Nat) : (x + y) * (x + y) = x * x + y * x + x * y + y * y :=
  calc (x + y) * (x + y)
    _ = (x + y) * x + (x + y) * y       := by rw [Nat.mul_add]
    _ = x * x + y * x + (x + y) * y     := by rw [Nat.add_mul]
    _ = x * x + y * x + (x * y + y * y) := by rw [Nat.add_mul]
    _ = x * x + y * x + x * y + y * y   := by rw [‚ÜêNat.add_assoc]
#+end_src

but a question:
  what the '...', '..' does?

Btw, if u wanna improve ur calcs with more than equalities, u can use
any other equivalence relation if u instance the Trans typeclass like this:
#+begin_src lean4
def divides (x y : Nat) : Prop :=
  ‚àÉ k, k*x = y

def divides_trans (h‚ÇÅ : divides x y) (h‚ÇÇ : divides y z) : divides x z :=
  let ‚ü®k‚ÇÅ, d‚ÇÅ‚ü© := h‚ÇÅ
  let ‚ü®k‚ÇÇ, d‚ÇÇ‚ü© := h‚ÇÇ
  ‚ü®k‚ÇÅ * k‚ÇÇ, by rw [Nat.mul_comm k‚ÇÅ k‚ÇÇ, Nat.mul_assoc, d‚ÇÅ, d‚ÇÇ]‚ü©

def divides_mul (x : Nat) (k : Nat) : divides x (k*x) :=
  ‚ü®k, rfl‚ü©

instance : Trans divides divides divides where
  trans := divides_trans

example (h‚ÇÅ : divides x y) (h‚ÇÇ : y = z) : divides x (2*z) :=
  calc
    divides x y     := h‚ÇÅ
    _ = z           := h‚ÇÇ
    divides _ (2*z) := divides_mul ..

infix:50 " ‚à£ " => divides

example (h‚ÇÅ : divides x y) (h‚ÇÇ : y = z) : divides x (2*z) :=
  calc
    x ‚à£ y   := h‚ÇÅ
    _ = z   := h‚ÇÇ
    _ ‚à£ 2*z := divides_mul ..
#+end_src

*** The Existential Quantifier
In summary, we have:
#+begin_src lean4
#check Exists.intro --> Exists.intro.{u} {Œ± : Sort u} {p : Œ± ‚Üí Prop} (w : Œ±) (h : p w) : Exists p
#check Exists.elim  --> Exists.elim.{u}  {Œ± : Sort u} {p : Œ± ‚Üí Prop} {b : Prop} (h‚ÇÅ : ‚àÉ x, p x) (h‚ÇÇ : ‚àÄ (a : Œ±), p a ‚Üí b) : b
#+end_src

But while the intro is very easy to get, the elim can sound a little weird. A path to
understand could be think in the existencial as a universal disjunction. So, when
u're trying to get away from a disjunction u might show a way from both of the sides.

So, note that in here, it could be anyone, like, u know that some a from alpha satisfy the p
predicate and then u can get out of this disjunction by it. So, if u have a path from all
a : alpha that satisfyes p and u have at least one x : alpha that does so, then u can get out
of there! That's how it works!

Btw, this quantifier has a very close relation with the sigma one and, maybe look out the
sigma could be useful latter.

*** More on the Proof Language
**** This
To start with, we can use anonymous "have" expressions to introduce an auxiliary goal without having to label it.
We can refer to the last expression introduced in this way using the keyword this:
#+begin_src lean4
variable (f : Nat ‚Üí Nat)
variable (h : ‚àÄ x : Nat, f x ‚â§ f (x + 1))

example : f 0 ‚â§ f 3 :=
  have : f 0 ‚â§ f 1 := h 0
  have : f 0 ‚â§ f 2 := Nat.le_trans this (h 1)
  show f 0 ‚â§ f 3 from Nat.le_trans this (h 2)
#+end_src

Here the text tells things about using "by assumption",
but it promise that will speak more about this latter.

** Tactics
*** Intro
**** Intro intro
Ok, this chapter is pretty long in a number of toppics
so i'll try to be very concise here

""Tactic commands can take compound expressions, not just single identifiers. Here's an example:
#+begin_src lean4
theorem test (p q : Prop) (hp : p) (hq : q) : p ‚àß q ‚àß p := by
  apply And.intro hp
  exact And.intro hq hp
#+end_src

**** {}
We have used . to create nested tactic blocks. In a nested block, Lean focuses on the first goal, and generates an error if it has not been fully solved at the end of the block. This can be helpful in indicating the separate proofs of multiple subgoals introduced by a tactic. The notation . is whitespace sensitive and relies on the indentation to detect whether the tactic block ends. Alternatively, you can define tactic blocks using curly braces and semicolons:
#+begin_src lean4
example (p q r : Prop) : p ‚àß (q ‚à® r) ‚Üî (p ‚àß q) ‚à® (p ‚àß r) := by
  apply Iff.intro
  { intro h;
    cases h.right;
    { show (p ‚àß q) ‚à® (p ‚àß r);
      exact Or.inl ‚ü®h.left, ‚Äπq‚Ä∫‚ü© }
    { show (p ‚àß q) ‚à® (p ‚àß r);
      exact Or.inr ‚ü®h.left, ‚Äπr‚Ä∫‚ü© } }
  { intro h;
    cases h;
    { show p ‚àß (q ‚à® r);
      rename_i hpq;
      exact ‚ü®hpq.left, Or.inl hpq.right‚ü© }
    { show p ‚àß (q ‚à® r);
      rename_i hpr;
      exact ‚ü®hpr.left, Or.inr hpr.right‚ü© } }
#+end_src

In summary u can use both of the above:

#+begin_src lean4
  apply foo
  . <proof of first goal>
  . <proof of second goal>
  . <proof of third goal>
  . <proof of final goal>
#+end_src

#+begin_src lean4
  apply foo
  case <tag of first goal>  => <proof of first goal>
  case <tag of second goal> => <proof of second goal>
  case <tag of third goal>  => <proof of third goal>
  case <tag of final goal>  => <proof of final goal>
#+end_src

#+begin_src lean4
  apply foo
  { <proof of first goal>  }
  { <proof of second goal> }
  { <proof of third goal>  }
  { <proof of final goal>  }
#+end_src

*** Basic tatics
**** by
To enter in tatic mode u use the
keyword "by". So, here's two very common ways to do this:

#+begin_src lean4
theorem test (p q : Prop) (hp : p) (hq : q) : p ‚àß q ‚àß p :=
  by apply And.intro
     exact hp
     apply And.intro
     exact hq
     exact hp
#+end_src

#+begin_src lean4
theorem test (p q : Prop) (hp : p) (hq : q) : p ‚àß q ‚àß p := by
  apply And.intro
  exact hp
  apply And.intro
  exact hq
  exact hp
#+end_src

**** apply
" The apply tactic applies an expression, viewed as denoting a function with zero or more arguments. It unifies the conclusion with the expression in the current goal, and creates new goals for the remaining arguments, provided that no later arguments depend on them. In the example above, the command apply And.intro"

I wanna know if i can see "apply" as some do for Props..

When subgoals are created they're tagged by names that could be inferred by the expression applied, by example. With that, u can use the tag name to reffer to the subgoal will wanna go first.

#+begin_src lean4
theorem test (p q : Prop) (hp : p) (hq : q) : p ‚àß q ‚àß p := by
  apply And.intro
  case left => exact hp
  case right =>
    apply And.intro
    case left => exact hq
    case right => exact hp
#+end_src

#+begin_src lean4
theorem test (p q : Prop) (hp : p) (hq : q) : p ‚àß q ‚àß p := by
  apply And.intro
  case right =>
    apply And.intro
    case left => exact hq
    case right => exact hp
  case left => exact hp
#+end_src

"For simple subgoals, it may not be worth selecting a
subgoal using its tag, but you may still want to structure the proof. Lean also provides the "bullet"" notation as bellow:

#+begin_src lean4
theorem test (p q : Prop) (hp : p) (hq : q) : p ‚àß q ‚àß p := by
  apply And.intro
  . exact hp
  . apply And.intro
    . exact hq
    . exact hp
#+end_src

**** exact
The exact command is just a variant of apply which signals that the expresion given should fill the goal exactly.

**** intro
"the intro tactic is a command for constructing function abstractions interactively (i.e., terms of the form fun x => e)"

here's some examples with introductions:

#+begin_src lean4
example (Œ± : Type) : Œ± ‚Üí Œ± := by
  intro a
  exact a

example (Œ± : Type) : ‚àÄ x : Œ±, x = x := by
  intro x
  exact Eq.refl x

-- We can use multiple arguments too!
  example : ‚àÄ a b c : Nat, a = b ‚Üí a = c ‚Üí c = b := by
  intro a b c h‚ÇÅ h‚ÇÇ
  exact Eq.trans (Eq.symm h‚ÇÇ) h‚ÇÅ
#+end_src

"As with lambda abstraction notation, the intro tactic allows us to use an implicit match."

#+begin_src lean4
example (Œ± : Type) (p q : Œ± ‚Üí Prop)
  : (‚àÉ x, p x ‚àß q x) ‚Üí ‚àÉ x, q x ‚àß p x :=
  by intro ‚ü®w, hpw, hqw‚ü©
     exact ‚ü®w, hqw, hpw‚ü©
#+end_src

Ok, thats kinda weird but you can also provide multiple
alternatives like in the match expression.

#+begin_src lean4
example (Œ± : Type) (p q : Œ± ‚Üí Prop) : (‚àÉ x, p x ‚à® q x) ‚Üí ‚àÉ x, q x ‚à® p x := by
  intro
  | ‚ü®w, Or.inl h‚ü© => exact ‚ü®w, Or.inr h‚ü©
  | ‚ü®w, Or.inr h‚ü© => exact ‚ü®w, Or.inl h‚ü©
#+end_src

You can "combine" intro h with match h:

#+begin_src lean4
example (p q r : Prop) : p ‚àß (q ‚à® r) ‚Üî (p ‚àß q) ‚à® (p ‚àß r) := by
  apply Iff.intro
  . intro
    | ‚ü®hp, Or.inl hq‚ü© => apply Or.inl; constructor <;> assumption
    | ‚ü®hp, Or.inr hr‚ü© => apply Or.inr; constructor <;> assumption
  . intro
    | Or.inl ‚ü®hp, hq‚ü© => constructor; assumption; apply Or.inl; assumption
    | Or.inr ‚ü®hp, hr‚ü© => constructor; assumption; apply Or.inr; assumption
#+end_src

**** intros
***** Basic
The intros tactic can be used without any arguments, in which case, it chooses names and introduces as many variables as it can.

#+begin_src lean4
example : ‚àÄ a b c : Nat, a = b ‚Üí a = c ‚Üí c = b := by
  intros
  apply Eq.trans
  apply Eq.symm
  assumption
  assumption
#+end_src

***** unhygienic

"That names automatically generated by Lean are inaccessible by default. The motivation is to ensure your tactic proofs do not rely on automatically generated names, and are consequently more robust. However, you can use the combinator unhygienic to disable this restriction."

#+begin_src lean4
example : ‚àÄ a b c : Nat, a = b ‚Üí a = c ‚Üí c = b := by unhygienic
  intros
  apply Eq.trans
  apply Eq.symm
  exact a_2
  exact a_1
#+end_src

***** rename_i
You can also use the rename_i tactic to rename the most recent inaccessible names in your context. In the following example, the tactic rename_i h1 _ h2 renames two of the last three hypotheses in your context.

#+begin_src lean4
example : ‚àÄ a b c d : Nat, a = b ‚Üí a = d ‚Üí a = c ‚Üí c = b := by
  intros
  rename_i h1 _ h2
  apply Eq.trans
  apply Eq.symm
  exact h2
  exact h1
#+end_src

**** assumption
It corresponds to the Thanos "imediato".

"The assumption tactic looks through the assumptions in context of the current goal, and if there is one matching the conclusion, it applies it."

#+begin_src lean4
example (x y z w : Nat) (h‚ÇÅ : x = y) (h‚ÇÇ : y = z) (h‚ÇÉ : z = w) : x = w := by
  apply Eq.trans h‚ÇÅ
  apply Eq.trans h‚ÇÇ
  assumption   -- applied h‚ÇÉ
#+end_src

**** refl
The rfl tactic is syntactic sugar for exact rfl:
#+begin_src lean4
example (y : Nat) : (fun x : Nat => 0) y = 0 :=
  by rfl
#+end_src
**** repeat
The repeat combinator can be used to apply a tactic several times:

#+begin_src lean4
example : ‚àÄ a b c : Nat, a = b ‚Üí a = c ‚Üí c = b := by
  intros
  apply Eq.trans
  apply Eq.symm
  repeat assumption
#+end_src
**** revert
in a sense, revert is an inverse to intro:
#+begin_src lean4
example (x : Nat) : x = x := by
  revert x
  -- goal is ‚ä¢ ‚àÄ (x : Nat), x = x
  intro y
  -- goal is y : Nat ‚ä¢ y = y
  rfl
#+end_src

Moving a hypothesis into the goal yields an implication, btw:

#+begin_src lean4
example (x y : Nat) (h : x = y) : y = x := by
  revert h
  -- goal is x y : Nat ‚ä¢ x = y ‚Üí y = x
  intro h‚ÇÅ
  -- goal is x y : Nat, h‚ÇÅ : x = y ‚ä¢ y = x
  apply Eq.symm
  assumption
#+end_src

"But revert is even more clever, in that it will revert not only an element of the context but also all the subsequent elements of the context that depend on it. For example, reverting x in the example above brings h along with it:"

#+begin_src lean4
example (x y : Nat) (h : x = y) : y = x := by
  revert x
  -- goal is y : Nat ‚ä¢ ‚àÄ (x : Nat), x = y ‚Üí y = x
  intros
  apply Eq.symm
  assumption
#+end_src

You can also revert multiple elements of the context at once, btw:
#+begin_src lean4
example (x y : Nat) (h : x = y) : y = x := by
  revert x y
  -- goal is ‚ä¢ ‚àÄ (x y : Nat), x = y ‚Üí y = x
  intros
  apply Eq.symm
  assumption
#+end_src

**** generalize
"You can only revert an element of the local context, that is, a local variable or hypothesis. But you can replace an arbitrary expression in the goal by a fresh variable using the generalize tactic:"

#+begin_src lean4
example : 3 = 3 := by
  generalize 3 = x
  -- goal is x : Nat ‚ä¢ x = x
  revert x
  -- goal is ‚ä¢ ‚àÄ (x : Nat), x = x
  intro y
  -- goal is y : Nat ‚ä¢ y = y
  rfl
#+end_src

To preserve the validity of the previous goal, the generalize tactic allows us to record the fact that 3 has been replaced by x. All you need to do is to provide a label, and generalize uses it to store the assignment in the local context:

#+begin_src lean4
example : 2 + 3 = 5 := by
  generalize h : 3 = x
  -- goal is x : Nat, h : 3 = x ‚ä¢ 2 + x = 5
  rw [‚Üê h]
#+end_src

**** admit
In this example, the admit tactic is the analogue of the sorry proof term:
#+begin_src lean4
example : 2 + 3 = 5 := by
  generalize h : 3 = x
  -- goal is x : Nat, h : 3 = x ‚ä¢ 2 + x = 5
  rw [‚Üê h]
#+end_src

**** cases
The cases tactic can be used to decompose a disjunction:
#+begin_src lean4
example (p q : Prop) : p ‚à® q ‚Üí q ‚à® p := by
  intro h
  cases h with
  | inl hp => apply Or.inr; exact hp
  | inr hq => apply Or.inl; exact hq
#+end_src

The cases tactic can also be used to decompose a conjunction:
#+begin_src lean4
example (p q : Prop) : p ‚àß q ‚Üí q ‚àß p := by
  intro h
  cases h with
  | intro hp hq => constructor; exact hq; exact hp
#+end_src

The new subgoals can be solved in any order, btw.
Another idea is to use a "unstructured `cases`" which
is particularly useful when you can close several subgoals using the same tactic:

#+begin_src lean4
example (p : Prop) : p ‚à® p ‚Üí p := by
  intro h
  cases h
  repeat assumption
#+end_src

You can combine the unstructured cases tactic with the case and . notation, btw:

#+begin_src lean4
example (p q : Prop) : p ‚à® q ‚Üí q ‚à® p := by
  intro h
  cases h
  . apply Or.inr
    assumption
  . apply Or.inl
    assumption

example (p q : Prop) : p ‚à® q ‚Üí q ‚à® p := by
  intro h
  cases h
  case inr h =>
    apply Or.inl
    assumption
  case inl h =>
    apply Or.inr
    assumption

example (p q : Prop) : p ‚à® q ‚Üí q ‚à® p := by
  intro h
  cases h
  case inr h =>
    apply Or.inl
    assumption
  . apply Or.inr
    assumption
#+end_src

We can keep using match instead, btw:

#+begin_src lean4
example (p q r : Prop) : p ‚àß (q ‚à® r) ‚Üî (p ‚àß q) ‚à® (p ‚àß r) := by
  apply Iff.intro
  . intro h
    match h with
    | ‚ü®_, Or.inl _‚ü© => apply Or.inl; constructor <;> assumption
    | ‚ü®_, Or.inr _‚ü© => apply Or.inr; constructor <;> assumption
  . intro h
    match h with
    | Or.inl ‚ü®hp, hq‚ü© => constructor; exact hp; apply Or.inl; exact hq
    | Or.inr ‚ü®hp, hr‚ü© => constructor; exact hp; apply Or.inr; exact hr
#+end_src

**** constructor
I dont think that u should be reading this summary for
this parts, so i'll keep c-y c-w them!

The constructor tactic applies the unique constructor for conjunction, And.intro.

With these tactics, an example from the previous section can be rewritten as follows:
#+begin_src lean4
example (p q r : Prop) : p ‚àß (q ‚à® r) ‚Üî (p ‚àß q) ‚à® (p ‚àß r) := by
  apply Iff.intro
  . intro h
    cases h with
    | intro hp hqr =>
      cases hqr
      . apply Or.inl; constructor <;> assumption
      . apply Or.inr; constructor <;> assumption
  . intro h
    cases h with
    | inl hpq =>
      cases hpq with
      | intro hp hq => constructor; exact hp; apply Or.inl; exact hq
    | inr hpr =>
      cases hpr with
      | intro hp hr => constructor; exact hp; apply Or.inr; exact hr
#+end_src

"You will see in Chapter Inductive Types that these tactics are quite general. The cases tactic can be used to decompose any element of an inductively defined type; constructor always applies the first applicable constructor of an inductively defined type. For example, you can use cases and constructor with an existential quantifier:"

#+begin_src lean4
example (p q : Nat ‚Üí Prop) : (‚àÉ x, p x) ‚Üí ‚àÉ x, p x ‚à® q x := by
  intro h
  cases h with
  | intro x px => constructor; apply Or.inl; exact px
#+end_src



**** exists
Is basically the old "use" or "escolho como testemunha" from Thanos.
#+begin_src lean4
example (p q : Nat ‚Üí Prop) : (‚àÉ x, p x) ‚Üí ‚àÉ x, p x ‚à® q x := by
  intro h
  cases h with
  | intro x px => exists x; apply Or.inl; exact px
#+end_src

basically it will be like the Exists.intro, receiving the argument (the witness)
but now interactively.

but it sounds to be more strong than only picking a witness because it'll
also try to show that that witness 'fits' as in the next example:
#+begin_src lean4
example (p q : Nat ‚Üí Prop) : (‚àÉ x, p x ‚àß q x) ‚Üí ‚àÉ x, q x ‚àß p x := by
  intro h
  cases h with
  | intro x hpq =>
    cases hpq with
    | intro hp hq =>
      exists x
#+end_src


**** tatics to functions defs
These tactics can be used on data just as well as propositions. In the next example, they are used to define functions which swap the components of the product and sum types:

#+begin_src lean4
def swap_pair : Œ± √ó Œ≤ ‚Üí Œ≤ √ó Œ± := by
  intro p
  cases p
  constructor <;> assumption

def swap_sum : Sum Œ± Œ≤ ‚Üí Sum Œ≤ Œ± := by
  intro p
  cases p
  . apply Sum.inr; assumption
  . apply Sum.inl; assumption
#+end_src

We could also use the cases with natural numbers:

#+begin_src lean4
open Nat
example (P : Nat ‚Üí Prop) (h‚ÇÄ : P 0) (h‚ÇÅ : ‚àÄ n, P (succ n)) (m : Nat) : P m := by
  cases m with
  | zero    => exact h‚ÇÄ
  | succ m' => exact h‚ÇÅ m'
#+end_src

**** contradiction
The contradiction tactic searches for a contradiction among the hypotheses of the current goal:
#+begin_src lean4
example (p q : Prop) : p ‚àß ¬¨ p ‚Üí q := by
  intro h
  cases h
  contradiction
#+end_src

**** show
In fact, there is a show tactic, which is similar to the show expression in a proof term. It simply declares the type of the goal that is about to be solved, while remaining in tactic mode, but u can combine it with froms and even bys, look:

#+begin_src lean4
example (p q r : Prop) : p ‚àß (q ‚à® r) ‚Üí (p ‚àß q) ‚à® (p ‚àß r) := by
  intro h
  exact
    have hp : p := h.left
    have hqr : q ‚à® r := h.right
    show (p ‚àß q) ‚à® (p ‚àß r) by
      cases hqr with
      | inl hq => exact Or.inl ‚ü®hp, hq‚ü©
      | inr hr => exact Or.inr ‚ü®hp, hr‚ü©
#+end_src

The show tactic can actually be used to rewrite a goal to something definitionally equivalent:
#+begin_src lean4
example (n : Nat) : n + 1 = Nat.succ n := by
  show Nat.succ n = Nat.succ n
  rfl
#+end_src

And there's my own:
#+begin_src lean4
example (a b c : Nat) (h‚ÇÅ : a ‚à£ b) (h‚ÇÇ : b ‚à£ c) : a ‚à£ c := by
  show ‚àÉ k, c = a * k
  have ‚ü®x, hab‚ü© := h‚ÇÅ
  have ‚ü®y, hbc‚ü© := h‚ÇÇ
  exists x * y
  have :=
    calc  a * (x * y) = (a * x) * y := by rw [‚ÜêNat.mul_assoc]
                    _ = b * y       := by rw [hab]
                    _ = c           := by rw [hbc]

  exact Eq.symm this
#+end_src

**** have
There is also a have tactic, which introduces a new subgoal, just as when writing proof terms:
#+begin_src lean4
example (p q r : Prop) : p ‚àß (q ‚à® r) ‚Üí (p ‚àß q) ‚à® (p ‚àß r) := by
  intro ‚ü®hp, hqr‚ü©
  show (p ‚àß q) ‚à® (p ‚àß r)
  cases hqr with
  | inl hq =>
    have hpq : p ‚àß q := And.intro hp hq
    apply Or.inl
    exact hpq
  | inr hr =>
    have hpr : p ‚àß r := And.intro hp hr
    apply Or.inr
    exact hpr
#+end_src

As with proof terms, you can omit the label in the have tactic, in which case, the default label this is used:
#+begin_src lean4
example (p q r : Prop) : p ‚àß (q ‚à® r) ‚Üí (p ‚àß q) ‚à® (p ‚àß r) := by
  intro ‚ü®hp, hqr‚ü©
  show (p ‚àß q) ‚à® (p ‚àß r)
  cases hqr with
  | inl hq =>
    have : p ‚àß q := And.intro hp hq
    apply Or.inl
    exact this
  | inr hr =>
    have : p ‚àß r := And.intro hp hr
    apply Or.inr
    exact this
#+end_src

The types in a have tactic can be omitted, so you can write have hp := h.left and have hqr := h.right. In fact, with this notation, you can even omit both the type and the label, in which case the new fact is introduced with the label this:
#+begin_src lean4
example (p q r : Prop) : p ‚àß (q ‚à® r) ‚Üí (p ‚àß q) ‚à® (p ‚àß r) := by
  intro ‚ü®hp, hqr‚ü©
  cases hqr with
  | inl hq =>
    have := And.intro hp hq
    apply Or.inl; exact this
  | inr hr =>
    have := And.intro hp hr
    apply Or.inr; exact this
#+end_src

Anyway, i would preffer to look through the types..

**** let
Lean also has a let tactic, which is similar to the have tactic, but is used to introduce local definitions instead of auxiliary facts. It is the tactic analogue of a let in a proof term:
#+begin_src lean4
example : ‚àÉ x, x + 2 = 8 := by
  let a : Nat := 3 * 2
  exists a
#+end_src

As with have, you can leave the type implicit by writing let a := 3 * 2. The difference between let and have is that let introduces a local definition in the context, so that the definition of the local declaration can be unfolded in the proof.

*** Combinators
**** <;> "combinator"
You can also use the combinator tac1 <;> tac2 to apply tac2 to each subgoal produced by tactic tac1:

#+begin_src lean4
example (p : Prop) : p ‚à® p ‚Üí p := by
  intro h
  cases h <;> assumption
#+end_src

In t‚ÇÅ <;> t‚ÇÇ, the <;> operator provides a parallel version of the sequencing operation: t‚ÇÅ is applied to the current goal, and then t‚ÇÇ is applied to all the resulting subgoals:

#+begin_src lean4
example (p q : Prop) (hp : p) (hq : q) : p ‚àß q :=
  by constructor <;> assumption
#+end_src

**** first combinator
The first | t‚ÇÅ | t‚ÇÇ | ... | t‚Çô applies each t·µ¢ until one succeeds, or else fails:

#+begin_src lean4
example (p q : Prop) (hp : p) : p ‚à® q := by
  first | apply Or.inl; assumption | apply Or.inr; assumption

example (p q : Prop) (hq : q) : p ‚à® q := by
  first | apply Or.inl; assumption | apply Or.inr; assumption
#+end_src
In the first example, the left branch succeeds, whereas in the second one, it is the right one that succeeds. In the next three examples, the same compound tactic succeeds in each case:

#+begin_src lean4
example (p q r : Prop) (hp : p) : p ‚à® q ‚à® r :=
  by repeat (first | apply Or.inl; assumption | apply Or.inr | assumption)

example (p q r : Prop) (hq : q) : p ‚à® q ‚à® r :=
  by repeat (first | apply Or.inl; assumption | apply Or.inr | assumption)

example (p q r : Prop) (hr : r) : p ‚à® q ‚à® r :=
  by repeat (first | apply Or.inl; assumption | apply Or.inr | assumption)
#+end_src

**** skip
skip is a tactic that does nothing (and succeeds in doing so).

#+begin_src lean4
example (p q : Prop) : p ‚à® q ‚Üí q ‚à® p := by
  intro h
  cases h
  ¬∑ rename_i hp
    skip
    exact Or.inr hp
  ¬∑ admit
#+end_src

**** try combinator
The try combinator builds a tactic that always succeeds, though possibly in a trivial way: try t executes t
and reports success, even if t fails. It is equivalent to first | t | skip.

In the next example, the second constructor succeeds on the right conjunct q ‚àß r (remember that disjunction and conjunction associate to the right) but fails on the first. The try tactic ensures that the sequential composition succeeds:
#+begin_src lean4
example (p q r : Prop) (hp : p) (hq : q) (hr : r) : p ‚àß q ‚àß r := by
  constructor <;> (try constructor) <;> assumption
#+end_src

Be careful: repeat (try t) will loop forever, because the inner tactic never fails.

**** all_goals
all_goals t applies t to all open goals:
#+begin_src lean4
example (p q r : Prop) (hp : p) (hq : q) (hr : r) : p ‚àß q ‚àß r := by
  constructor
  all_goals (try constructor)
  all_goals assumption
#+end_src

**** any_goals
In this case, the any_goals tactic provides a more robust solution. It is similar to all_goals, except it succeeds if its argument succeeds on at least one goal:

#+begin_src lean4
example (p q r : Prop) (hp : p) (hq : q) (hr : r) : p ‚àß q ‚àß r := by
  constructor
  any_goals constructor
  any_goals assumption
#+end_src

#+begin_src lean4
example (p q r : Prop) (hp : p) (hq : q) (hr : r) :
      p ‚àß ((p ‚àß q) ‚àß r) ‚àß (q ‚àß r ‚àß p) := by
  repeat (any_goals (first | constructor | assumption))
#+end_src

Look this unlegible crazyness:
#+begin_src lean4
example (p q r : Prop) (hp : p) (hq : q) (hr : r) :
      p ‚àß ((p ‚àß q) ‚àß r) ‚àß (q ‚àß r ‚àß p) := by
  repeat (any_goals (first | constructor | assumption))
#+end_src
**** focus
The combinator focus t ensures that t only effects the current goal, temporarily hiding the others from the scope. So, if t ordinarily only effects the current goal, focus (all_goals t) has the same effect as t.

no examples were provided and i dont know if im really interested in this one..

*** Rewriting
**** rw
It's an abbreviation to rewrite.

The most basic form of the tactic is rewrite [t], where t is a term whose type asserts an equality. For example,
t can be a hypothesis h : x = y in the context; it can be a general lemma, like add_comm : ‚àÄ x y, x + y = y + x,
in which the rewrite tactic tries to find suitable instantiations of x and y; or it can be any compound term asserting
a concrete or general equation. In the following example, we use this basic form to rewrite the goal using a hypothesis.

#+begin_src lean4
example (f : Nat ‚Üí Nat) (k : Nat) (h‚ÇÅ : f 0 = 0) (h‚ÇÇ : k = 0) : f k = 0 := by
  rw [h‚ÇÇ] -- replace k with 0
  rw [h‚ÇÅ] -- replace f 0 with 0
#+end_src

 Note that the tactic automatically closes any goal of the form t = t.

 Multiple rewrites can be combined using the notation rw [t_1, ..., t_n], which is just shorthand for rw [t_1]; ...; rw [t_n]. The previous example can be written as follows:
 #+begin_src lean4
example (f : Nat ‚Üí Nat) (k : Nat) (h‚ÇÅ : f 0 = 0) (h‚ÇÇ : k = 0) : f k = 0 := by
  rw [h‚ÇÇ, h‚ÇÅ]
 #+end_src

 The notation ‚Üêt can be used to instruct the tactic to use the equality t in the reverse direction.
 #+begin_src lean4
example (f : Nat ‚Üí Nat) (a b : Nat) (h‚ÇÅ : a = b) (h‚ÇÇ : f a = 0) : f b = 0 := by
  rw [‚Üêh‚ÇÅ, h‚ÇÇ]
 #+end_src

 Sometimes the left-hand side of an identity can match more than one subterm in the pattern, in which case the rw tactic chooses the first match it finds when traversing the term. If that is not the one you want, you can use additional arguments to specify the appropriate subterm.

 #+begin_src lean4
example (a b c : Nat) : a + b + c = a + c + b := by
  rw [Nat.add_assoc, Nat.add_comm b, ‚Üê Nat.add_assoc]

example (a b c : Nat) : a + b + c = a + c + b := by
  rw [Nat.add_assoc, Nat.add_assoc, Nat.add_comm b]

example (a b c : Nat) : a + b + c = a + c + b := by
  rw [Nat.add_assoc, Nat.add_assoc, Nat.add_comm _ b]
 #+end_src

By default, the rewrite tactic affects only the goal. The notation rw [t] at h applies the rewrite t at hypothesis h.
`at`:

#+begin_src lean4
example (f : Nat ‚Üí Nat) (a : Nat) (h : a + 0 = 0) : f a = f 0 := by
  rw [Nat.add_zero] at h
  rw [h]
#+end_src

The rewrite tactic is not restricted to propositions. In the following example, we use rw [h] at t to rewrite the hypothesis t : Tuple Œ± n to t : Tuple Œ± 0.

#+begin_src lean4
def Tuple (Œ± : Type) (n : Nat) :=
  { as : List Œ± // as.length = n }

example (n : Nat) (h : n = 0) (t : Tuple Œ± n) : Tuple Œ± 0 := by
  rw [h] at t
  exact t
#+end_src

**** simp

The lean4 book talks so much about it when i dont even wanna use it..
Maybe it would be cool when it will come to so much calculations..

we have already the `simp_arith` to do this, btw:
#+begin_src lean4
example (xs ys : List Nat) (h : g xs ys = 0) : False := by
  simp [g] at h; split at h <;> simp +arith at h
#+end_src

Whereas rewrite is designed as a surgical tool for manipulating a goal, the simplifier offers a more powerful form of automation. A number of identities in Lean's library have been tagged with the [simp] attribute, and the simp tactic uses them to iteratively rewrite subterms in an expression.

now it looks like to be `simp +arith`, btw.

#+begin_src lean4
example (x y z : Nat) : (x + 0) * (0 + y * 1 + z * 0) = x * y := by
  simp

example (x y z : Nat) (p : Nat ‚Üí Prop) (h : p (x * y))
        : p ((x + 0) * (0 + y * 1 + z * 0)) := by
  simp; assumption
#+end_src

As with rw, you can use the keyword at to simplify a hypothesis:
#+begin_src lean4
example (x y z : Nat) (p : Nat ‚Üí Prop)
        (h : p ((x + 0) * (0 + y * 1 + z * 0))) : p (x * y) := by
  simp at h; assumption
#+end_src

Moreover, you can use a "wildcard" asterisk to simplify all the hypotheses and the goal:

#+begin_src lean4
attribute [local simp] Nat.mul_comm Nat.mul_assoc Nat.mul_left_comm
attribute [local simp] Nat.add_assoc Nat.add_comm Nat.add_left_comm

example (w x y z : Nat) (p : Nat ‚Üí Prop)
        (h : p (x * y + z * w * x)) : p (x * w * z + y * x) := by
  simp at *; assumption

example (x y z : Nat) (p : Nat ‚Üí Prop)
        (h‚ÇÅ : p (1 * x + y)) (h‚ÇÇ : p (x * z * 1))
        : p (y + 0 + x) ‚àß p (z * x) := by
  simp at * <;> constructor <;> assumption
#+end_src

As with rewrite, you can send simp a list of facts to use, including general lemmas, local hypotheses, definitions to unfold, and compound expressions. The simp tactic also recognizes the ‚Üêt syntax that rewrite does. In any case, the additional rules are added to the collection of identities that are used to simplify a term.

#+begin_src lean4
def f (m n : Nat) : Nat :=
  m + n + m

example {m n : Nat} (h : n = 1) (h' : 0 = m) : (f m n) = n := by
  simp [h, ‚Üêh', f]
#+end_src

To use all the hypotheses present in the local context when simplifying, we can use the wildcard symbol, *:

#+begin_src lean4
example (f : Nat ‚Üí Nat) (k : Nat) (h‚ÇÅ : f 0 = 0) (h‚ÇÇ : k = 0) : f k = 0 := by
  simp [*]
#+end_src

The simplifier will also do propositional rewriting. For example, using the hypothesis p, it rewrites p ‚àß q to q and p ‚à® q to true, which it then proves trivially. Iterating such rewrites produces nontrivial propositional reasoning.

#+begin_src lean4
example (p q : Prop) (hp : p) : p ‚àß q ‚Üî q := by
  simp [*]

example (p q : Prop) (hp : p) : p ‚à® q := by
  simp [*]

example (p q r : Prop) (hp : p) (hq : q) : p ‚àß (q ‚à® r) := by
  simp [*]
#+end_src

The next example simplifies all the hypotheses, and then uses them to prove the goal.

#+begin_src lean4
example (u w x x' y y' z : Nat) (p : Nat ‚Üí Prop)
        (h‚ÇÅ : x + 0 = x') (h‚ÇÇ : y + 0 = y')
        : x + y + 0 = x' + y' := by
  simp at *
  simp [*]
#+end_src

 it would be nice if users did not have to invoke it explicitly.
 You can achieve that by marking it as a simplification rule when the theorem is defined:

 #+begin_src lean4
def mk_symm (xs : List Œ±) :=
 xs ++ xs.reverse

@[simp] theorem reverse_mk_symm (xs : List Œ±)
        : (mk_symm xs).reverse = mk_symm xs := by
  simp [mk_symm]

example (xs ys : List Nat)
        : (xs ++ mk_symm ys).reverse = mk_symm ys ++ xs.reverse := by
  simp

example (xs ys : List Nat) (p : List Nat ‚Üí Prop)
        (h : p (xs ++ mk_symm ys).reverse)
        : p (mk_symm ys ++ xs.reverse) := by
  simp at h; assumption
 #+end_src

 The notation @[simp] declares reverse_mk_symm to have the [simp] attribute, and can be spelled out more explicitly:
 #+begin_src lean4
def mk_symm (xs : List Œ±) :=
 xs ++ xs.reverse
theorem reverse_mk_symm (xs : List Œ±)
        : (mk_symm xs).reverse = mk_symm xs := by
  simp [mk_symm]

attribute [simp] reverse_mk_symm

example (xs ys : List Nat)
        : (xs ++ mk_symm ys).reverse = mk_symm ys ++ xs.reverse := by
  simp

example (xs ys : List Nat) (p : List Nat ‚Üí Prop)
        (h : p (xs ++ mk_symm ys).reverse)
        : p (mk_symm ys ++ xs.reverse) := by
  simp at h; assumption
 #+end_src

There are two additional modifiers that are useful. By default, simp includes all theorems that have been marked with the attribute [simp]. Writing simp only excludes these defaults, allowing you to use a more explicitly crafted list of rules. In the examples below, the minus sign and only are used to block the application of reverse_mk_symm.

#+begin_src lean4
def mk_symm (xs : List Œ±) :=
  xs ++ xs.reverse
@[simp] theorem reverse_mk_symm (xs : List Œ±)
        : (mk_symm xs).reverse = mk_symm xs := by
  simp [mk_symm]

example (xs ys : List Nat) (p : List Nat ‚Üí Prop)
        (h : p (xs ++ mk_symm ys).reverse)
        : p (mk_symm ys ++ xs.reverse) := by
  simp at h; assumption

example (xs ys : List Nat) (p : List Nat ‚Üí Prop)
        (h : p (xs ++ mk_symm ys).reverse)
        : p ((mk_symm ys).reverse ++ xs.reverse) := by
  simp [-reverse_mk_symm] at h; assumption

example (xs ys : List Nat) (p : List Nat ‚Üí Prop)
        (h : p (xs ++ mk_symm ys).reverse)
        : p ((mk_symm ys).reverse ++ xs.reverse) := by
  simp only [List.reverse_append] at h; assumption
#+end_src

The simp tactic has many configuration options. For example, we can enable contextual simplifications as follows:

#+begin_src lean4
example : if x = 0 then y + x = y else x ‚â† 0 := by
  simp (config := { contextual := true })
#+end_src

Another useful configuration option is arith := true which enables arithmetical simplifications. It is so useful that simp_arith is a shorthand for simp (config := { arith := true }):
#+begin_src lean4
example : 0 < 1 + x ‚àß x + y + 2 ‚â• y + 1 := by
  simp_arith
#+end_src

I'm not interested in simp's btw :P

**** local
The local modifier tells the simplifier to use these rules in the current file (or section or namespace, as the case may be). It may seem that commutativity and left-commutativity are problematic, in that repeated application of either causes looping.

#+begin_src lean4
attribute [local simp] Nat.mul_comm Nat.mul_assoc Nat.mul_left_comm
attribute [local simp] Nat.add_assoc Nat.add_comm Nat.add_left_comm

example (w x y z : Nat) (p : Nat ‚Üí Prop)
        (h : p (x * y + z * w * x)) : p (x * w * z + y * x) := by
  simp at *; assumption

example (x y z : Nat) (p : Nat ‚Üí Prop)
        (h‚ÇÅ : p (1 * x + y)) (h‚ÇÇ : p (x * z * 1))
        : p (y + 0 + x) ‚àß p (z * x) := by
  simp at * <;> constructor <;> assumption
#+end_src

*** Split
The split tactic is useful for breaking nested if-then-else and match expressions in cases. For a match expression with n cases, the split tactic generates at most n subgoals. Here is an example:

#+begin_src lean4
def f (x y z : Nat) : Nat :=
 match x, y, z with
 | 5, _, _ => y
 | _, 5, _ => y
 | _, _, 5 => y
 | _, _, _ => 1

example (x y z : Nat) : x ‚â† 5 ‚Üí y ‚â† 5 ‚Üí z ‚â† 5 ‚Üí z = w ‚Üí f x y w = 1 := by
  intros; simp [f]; split <;> first | contradiction | rfl
#+end_src

Like simp, we can apply split to a particular hypothesis:
#+begin_src lean4
def g (xs ys : List Nat) : Nat :=
  match xs, ys with
  | [a, b], _ => a+b+1
  | _, [b, c] => b+1
  | _, _      => 1

example (xs ys : List Nat) (h : g xs ys = 0) : False := by
  simp [g] at h; split at h <;> simp_arith at h
#+end_src

*** Extensible  (macro)
You can provide different expansions, and the tactic interpreter will try all of them until one succeeds:
(the text is all..)
#+begin_src lean4
-- Define a new tactic notation
syntax "triv" : tactic

macro_rules
  | `(tactic| triv) => `(tactic| assumption)

example (h : p) : p := by
  triv

-- You cannot prove the following theorem using `triv`
-- example (x : Œ±) : x = x := by
--  triv

-- Let's extend `triv`. The tactic interpreter
-- tries all possible macro extensions for `triv` until one succeeds
macro_rules
  | `(tactic| triv) => `(tactic| rfl)

example (x : Œ±) : x = x := by
  triv

example (x : Œ±) (h : p) : x = x ‚àß p := by
  apply And.intro <;> triv

-- We now add a (recursive) extension
macro_rules | `(tactic| triv) => `(tactic| apply And.intro <;> triv)

example (x : Œ±) (h : p) : x = x ‚àß p := by
  triv

#+end_src
